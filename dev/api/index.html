<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BlochSimulators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlochSimulators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../dictionary/">MR Fingerprinting Dictionary Generation</a></li><li><a class="tocitem" href="../signal/">Simulate MR Signal</a></li><li><a class="tocitem" href="../adiabatic/">Adiabatic inversion</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Isochromat-Operators"><span>Isochromat Operators</span></a></li><li><a class="tocitem" href="#EPG-Operators"><span>EPG Operators</span></a></li><li><a class="tocitem" href="#Tissue-Parameters"><span>Tissue Parameters</span></a></li><li><a class="tocitem" href="#Sequences"><span>Sequences</span></a></li><li><a class="tocitem" href="#Trajectories"><span>Trajectories</span></a></li><li><a class="tocitem" href="#Dictionary-Simulation"><span>Dictionary Simulation</span></a></li><li><a class="tocitem" href="#Signal-Simulation"><span>Signal Simulation</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Isochromat-Operators"><a class="docs-heading-anchor" href="#Isochromat-Operators">Isochromat Operators</a><a id="Isochromat-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Isochromat-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Isochromat" href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Isochromat{T&lt;:Real} &lt;: FieldVector{3,T}
    x::T
    y::T
    z::T
end</code></pre><p>Holds the x,y,z components of a spin isochromat in a FieldVector, which is a <code>StaticVector</code> (from the package <code>StaticArrays</code>) with custom fieldnames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T" href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay(m::Isochromat{T}, E₁, E₂) where T</code></pre><p>Apply T₂ decay to transverse component and T₁ decay to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T" href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T</code></pre><p>Initialize a spin isochromat to be used throughout a simulation of the sequence.</p><p>This may seem redundant but to is necessary to share the same programming interface with <code>EPGSimulators</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T" href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueParameters) where T</code></pre><p>Invert <code>Isochromat</code> with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T" href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueParameters) where T</code></pre><p>Invert z-component of <code>Isochromat</code> (assuming spoiled transverse magnetization so xy-component zero).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T" href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth(m::Isochromat{T}, E₁) where T</code></pre><p>Apply T₁ regrowth to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}" href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueParameters)</code></pre><p>Rotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T" href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat{T}, γΔtRF::Complex, γΔtGR::Tuple, (x,y,z), Δt, p::AbstractTissueParameters, Δω = zero(T)) where T</code></pre><p>RF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues rotation formula (https://en.wikipedia.org/wiki/Rodrigues%27<em>rotation</em>formula).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample transverse magnetization from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S" href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample m.x, m.y and m.z components from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/isochromat.jl#L156-L161">source</a></section></article><h2 id="EPG-Operators"><a class="docs-heading-anchor" href="#EPG-Operators">EPG Operators</a><a id="EPG-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#EPG-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.EPGStates" href="#BlochSimulators.EPGStates"><code>BlochSimulators.EPGStates</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EPGStates = Union{MMatrix{3}, SizedMatrix{3}}</code></pre><p>In the EPG model, the configuration state matrix <code>Ω</code> will be updated inplace. On CPU, we use <code>StaticArrays.MMatrix</code>. The MMatrix will not escape <code>_simulate!</code> and therefore should not result in allocations. On GPU, we use shared memory (<code>CUDA.CuStaticSharedArray</code>). The shared memory is allocated for all threads within a block simultaneously. We then take a <code>@view</code> and wrap it in a <code>SizedArray</code>. Without the <code>SizedArray</code>, the type would be long and unreadable. By wrapping, we can then simply dispatch on a <code>SizedArray</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F̄₋-Tuple{Any}" href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F̄₋(Ω)</code></pre><p>View into the second row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F̄₋</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F₊-Tuple{Any}" href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F₊(Ω)</code></pre><p>View into the first row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F₊</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Z-Tuple{Any}" href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z(Ω)</code></pre><p>View into the third row of the configuration state matrix <code>Ω</code>, corresponding to the <code>Z</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}" href="#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}"><code>BlochSimulators.decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay!(Ω::EPGStates, E₁, E₂)</code></pre><p>T₂ decay for F-components, T₁ decay for <code>Z</code>-component of each state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.dephasing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dephasing!(Ω::EPGStates)</code></pre><p>Shift states around due to dephasing gradient: The <code>F₊</code> go up one, the <code>F̄₋</code> go down one and <code>Z</code> do not change</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::EPGStates, RF::Complex, p::AbstractTissueParameters)</code></pre><p>Mixing of states due to RF pulse. Magnitude of RF is the flip angle in degrees. Phase of RF is the phase of the pulse. If RF is real, the computations simplify a little bit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::EPGStates, RF::T, p::AbstractTissueParameters) where T&lt;:Union{Real, Quantity{&lt;:Real}}</code></pre><p>If RF is real, the calculations simplify (and probably Ω is real too, reducing memory (access) requirements).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.initial_conditions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_conditions!(Ω::EPGStates)</code></pre><p>Set all components of all states to 0, except the Z-component of the 0th state which is set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an <code>MMatrix</code> of EPG states on CPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an array of EPG states on a CUDA GPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}" href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::EPGStates, p::AbstractTissueParameters)</code></pre><p>Invert <code>Z</code>-component of states of all orders. <em>Assumes fully spoiled transverse magnetization</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::EPGStates)</code></pre><p>Invert with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}" href="#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}"><code>BlochSimulators.regrowth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth!(Ω::EPGStates, E₁)</code></pre><p>T₁ regrowth for Z-component of 0th order state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T" href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T"><code>BlochSimulators.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate!(Ω::EPGStates, eⁱᶿ::T) where T</code></pre><p>Rotate <code>F₊</code> and <code>F̄₋</code> states under the influence of <code>eⁱᶿ = exp(i * ΔB₀ * Δt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}" href="#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_decay!(Ω::EPGStates, E₁, E₂, eⁱᶿ)</code></pre><p>Rotate and decay combined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)</code></pre><p>Sample the measurable transverse magnetization, that is, the <code>F₊</code> component of the 0th state. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_Ω!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)</code></pre><p>Sample the entire configuration state matrix <code>Ω</code>. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.spoil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spoil!(Ω::EPGStates)</code></pre><p>Perfectly spoil the transverse components of all states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}" href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}</code></pre><p>By default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/operators/epg.jl#L40-L47">source</a></section></article><h2 id="Tissue-Parameters"><a class="docs-heading-anchor" href="#Tissue-Parameters">Tissue Parameters</a><a id="Tissue-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Tissue-Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTissueParameters" href="#BlochSimulators.AbstractTissueParameters"><code>BlochSimulators.AbstractTissueParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTissueParameters{N,T} &lt;: FieldVector{N,T}</code></pre><p>Abstract type for structs that hold different combinations of tissue parameters.</p><p><strong>Possible fields</strong></p><ul><li><code>T₁::T</code>: T₁ relaxation parameters of a voxel</li><li><code>T₂::T</code>: T₂ relaxation parameters of a voxel</li><li><code>B₁::T</code>: Scaling factor for effective B₁ excitation field within a voxel</li><li><code>B₀::T</code>: Off-resonance with respect to main magnetic field within a voxel</li><li><code>ρˣ::T</code>: Real part of proton density within a voxel</li><li><code>ρʸ::T</code>: Imaginary part of proton density within a voxel</li></ul><p>The structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:</p><ol><li>FieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons</li><li>The named fields improve readability of the code (e.g. <code>p.B₁</code> vs <code>p[3]</code>)</li><li>Linear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/interfaces/tissueparameters.jl#L1-L21">source</a></section></article><h2 id="Sequences"><a class="docs-heading-anchor" href="#Sequences">Sequences</a><a id="Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Sequences" title="Permalink"></a></h2><h4 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.BlochSimulator" href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlochSimulator{T}</code></pre><p>The abstract type of which all sequence simulators will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an <code>AbstractTrajectory</code> will be needed as well.</p><p>To make a simulator for a particular pulse sequence:</p><ol><li><p>Make a struct that&#39;s a subtype of either <code>IsochromatSimulator</code> or <code>EPGSimulator</code>.  The struct will hold parameters that are necessary for performing the simulations.</p></li><li><p>Add a method to <code>simulate_magnetization!</code> that implements the pulse sequence. For both performance and GPU compatibility,  make sure that <code>simulate_magnetization!</code> does not do any heap allocations. Examples for <code>pSSFP</code> and <code>FISP</code>  sequences are found in <code>src/sequences</code>.</p></li><li><p>Add methods to <code>output_eltype</code> and <code>output_size</code> that are used to allocate an output array within the simulate function.</p></li><li><p>[Optional] Add a method to show for nicer printing of the sequence in the REPL</p></li><li><p>[Optional] Add a method to getindex to easily reduce the length of the sequence</p></li><li><p>[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct</p></li></ol><p><strong>IMPORTANT</strong></p><p>The <code>simulate_magnetization!</code> functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from <code>operators/epg.jl</code><code>and</code>operators/isochromat.jl` and a properly parametrized sequence struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/interfaces/sequences.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.IsochromatSimulator" href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsochromatSimulator{T} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/interfaces/sequences.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.EPGSimulator" href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EPGSimulator{T,Ns} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter <code>Ns</code> corresponds to the maximum order of configuration states that are tracked in the simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/interfaces/sequences.jl#L50-L58">source</a></section></article><h4 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h4><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic2D" href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic2D{T,V,M,S} where {T&lt;:AbstractFloat, V&lt;:AbstractVector, M&lt;:AbstractMatrix, S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li><li><code>z::V{T}</code>: Vector with different positions along the slice direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/sequences/generic2d.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic3D" href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic3D{T,V&lt;:AbstractVector{Complex{T}},W&lt;:AbstractVector{T},M&lt;:AbstractMatrix{T},S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/sequences/generic3d.jl#L1-L11">source</a></section></article><h2 id="Trajectories"><a class="docs-heading-anchor" href="#Trajectories">Trajectories</a><a id="Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectories" title="Permalink"></a></h2><h4 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTrajectory" href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTrajectory{T}</code></pre><p>The abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence. The type T refers to the precision of the floating point values within the trajectory struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/interfaces/trajectories.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.SpokesTrajectory" href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpokesTrajectory{T} &lt;: AbstractTrajectory{T}</code></pre><p>Typical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory such that some methods that would be the same for both trajectories otherwise are written for SpokesTrajectory instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/cartesian.jl#L3-L11">source</a></section></article><h4 id="Interface-2"><a class="docs-heading-anchor" href="#Interface-2">Interface</a><a class="docs-heading-anchor-permalink" href="#Interface-2" title="Permalink"></a></h4><h4 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.CartesianTrajectory" href="#BlochSimulators.CartesianTrajectory"><code>BlochSimulators.CartesianTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CartesianTrajectory{T,I,U,V} &lt;: SpokesTrajectory{T}</code></pre><p>Struct that is used to implement a typical Cartesian gradient trajectory. The trajectory is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δkₓ per sample point (same for all readouts)</li><li><code>py::V</code>: Phase encoding index for each readout</li><li><code>readout_oversampling::I</code>: Readout oversampling factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/cartesian.jl#L16-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}" href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::CartesianTrajectory)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/cartesian.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, Any, CartesianTrajectory, Any, Any}" href="#BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, Any, CartesianTrajectory, Any, Any}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Arguments</p><ul><li><code>magnetization</code>:          Matrix{Complex} of size (# readouts, # voxels) with phase-encoded                   magnetization at echo times.</li><li><code>parameters</code>:     Tissue parameters of all voxels, including spatial coordinates.</li><li><code>trajectory</code>:     Cartesian trajectory struct.</li><li><code>coordinates</code>:    Vector{Coordinates} with spatial coordinates for each voxel.</li><li><code>coil_sensitivities</code>:     Matrix{Complex} of size (# voxels, # coils) with coil sensitivities.</li></ul><p>Output:</p><ul><li><code>signal</code>: Vector of length (# coils) with each element a Matrix{Complex}       of size (# readouts, # samples per readout)</li></ul><p>Description:</p><p>As noted in the description of the simulate_signal function (see <code>src/simulate/signal.jl</code>), we simulate the MR signal at timepoint <code>t</code> from coil <code>i</code> as: signalᵢ[t] = sum(m[t,v] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)), where <code>cᵢ</code>is the coil sensitivity profile of coil <code>i</code>, <code>ρ</code> is the proton density map and <code>m</code> the matrix with the magnetization at all timepoints for each voxel obtained through Bloch simulations.</p><p>The output (signalᵢ) for each coil is in principle a <code>Vector{Complex}</code><code>of length (# samples per readout) * (# readouts). If we reshape the output into a</code>Matrix{Complex}<code>of size (# samples per readout, # readouts) instead, and do something similar for</code>m`, then the signal value associated with the s-th sample point of the r-th readout can be expressed as signalᵢ[r,s] = sum( m[r,s,v]] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)).</p><p>The problem here is that we typically cannot store the full m. Instead, we compute the magnetization at echo times only. The reason is that, if mᵣ is the magnetization at the r-th echo time in some voxel, and E = exp(-Δt<em>R₂[v]) * exp(im</em>(Δkₓ*x[v])) is the change per sample point (WHICH FOR CARTESIAN SEQUENCES IS THE SAME FOR ALL READOUTS AND SAMPLES), then the magnetization at the s-th sample relative the the echo time can can be computed as mₛ = mᵣ * E[v]^s</p><p>Therefore we can write</p><p>signalⱼ[r,s] = sum( magnetization[r,v] * E[v]^s * ρ[v] * cⱼ[v] for v in 1:(# voxels)) signalⱼ[r,s] = magnetization[r,:] * (E.^s .* ρ .* cⱼ)</p><p>Because the (E.^s .* ρ .* cⱼ)-part is the same for all readouts, we can simply perform this computation for all readouts simultaneously as signalⱼ[:,s] = magnetization * (E.^s .* ρ .* cⱼ)</p><p>If we define the matrix Eˢ as E .^ (-(ns÷2):(ns÷2)-1), then we can do the computation for all different sample points at the same time as well using a single matrix-matrix multiplication: signalⱼ = magnetization * (Eˢ .* (ρ .* cⱼ))</p><p>The signalⱼ array is of size (# readouts, # samples per readout). We prefer to have it transposed, therefore we compute signalⱼ = transpose(Eˢ .* (ρ .* cⱼ)) * transpose(magnetization) instead.</p><p>For the final output, we do this calculation for each coil j and get a vector of signal matrices (one matrix for each coil) as a result.</p><p>Note that this implementation relies entirely on vectorized code and works on both CPU and GPU. The matrix-matrix multiplications are - I think - already multi-threaded so a separate multi-threaded implementation is not needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/cartesian.jl#L57-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}" href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}"><code>BlochSimulators.sampling_mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampling_mask(tr::CartesianTrajectory)</code></pre><p>For undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/cartesian.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.RadialTrajectory" href="#BlochSimulators.RadialTrajectory"><code>BlochSimulators.RadialTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialTrajectory{T,I,U,V} &lt;: SpokesTrajectory{T}</code></pre><p>Struct that is used to implement a typical radial gradient trajectory. The trajectory can is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δk between each readout</li><li><code>φ::V</code>: Radial angle for each readout</li><li><code>readout_oversampling::I</code>: Readout oversampling factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/radial.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}" href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}"><code>BlochSimulators.add_gradient_delay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_gradient_delay!(tr::RadialTrajectory, S)</code></pre><p>Apply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/radial.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}" href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::RadialTrajectory)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/examples/trajectories/radial.jl#L114-L118">source</a></section></article><h2 id="Dictionary-Simulation"><a class="docs-heading-anchor" href="#Dictionary-Simulation">Dictionary Simulation</a><a id="Dictionary-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionary-Simulation" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simulate_magnetization(resource, sequence, parameters)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}" href="#BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}"><code>BlochSimulators._allocate_array_on_resource</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_array_on_resource(resource::AbstractResource, _eltype, _size)</code></pre><p>Allocate an array on the specified <code>resource</code> with the given element type <code>_eltype</code> and size <code>_size</code>. If <code>resource</code> is <code>CPU1()</code> or <code>CPUThreads()</code>, the array is allocated on the CPU. If <code>resource</code> is <code>CUDALibs()</code>, the array is allocated on the GPU. For <code>CPUProcesses()</code>, the array is distributed in the &quot;voxel&quot;-dimension over multiple CPU workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/magnetization.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_magnetization_array-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}}} where {N, T}" href="#BlochSimulators._allocate_magnetization_array-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}}} where {N, T}"><code>BlochSimulators._allocate_magnetization_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_magnetization_array(resource, sequence, parameters)</code></pre><p>Allocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the <code>sequence</code>. For each <code>BlochSimulator</code>, methods should have been added to <code>output_eltype</code> and <code>output_size</code> for this function to work properly.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: The computational resource (e.g., CPU, GPU) to be used for the allocation.</li><li><code>sequence::BlochSimulator{T}</code>: The simulator, which defines the type of simulation to be performed.</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters{N,T}}</code>: A vector with each element containing the tissue parameters for a voxel.</li></ul><p><strong>Returns</strong></p><ul><li><code>magnetization_array</code>: An array allocated on the specified <code>resource</code>, formatted to store the simulation results for each voxel across the specified echo times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/magnetization.jl#L98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}" href="#BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization!(magnetization, resource, sequence, parameters)</code></pre><p>Simulate the magnetization at echo times (without any spatial encoding gradients applied) for all combinations of tissue parameters contained in <code>parameters</code>. Stores the magnetization response (typically the transverse magnetization at echo times) in the <code>magnetization</code> array.</p><ul><li><code>magnetization::AbstractArray</code>: Pre-allocated output array to store simulation results.</li><li><code>resource::AbstractResource</code>: Computational resource (e.g., <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code>, <code>CUDALibs()</code>).</li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters}</code>: Vector with different combinations of tissue parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/magnetization.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_magnetization(sequence, parameters)</code></pre><p>Convenience function to simulate magnetization without specifying the computational resource. The function automatically selects the appropriate resource based on the type of the <code>parameters</code> argument.</p><ul><li>If the <code>parameters</code> are provided as a CuArray, the <code>sequence</code> is made GPU-compatible as well and the simulation is performed on the GPU.</li><li>If the <code>parameters</code> are provided as a DArray, the simulation is performed on the multiple workers.</li><li>If the <code>parameters</code> are provided as a regular array, the simulation is performed on the CPU in a multi-threaded fashion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/magnetization.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(resource, sequence, parameters)</code></pre><p>Simulate the magnetization response (typically the transverse magnetization at echo times without any spatial encoding gradients applied) for all combinations of tissue parameters contained in <code>parameters</code>.</p><p>This function can also be used to generate dictionaries for MR Fingerprinting purposes.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters}</code>: Vector with different combinations of tissue parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>magnetization::AbstractArray</code>: Array of size (output_size(sequence), length(parameters)) containing the   magnetization response of the sequence for all combinations of input tissue parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/magnetization.jl#L1-L17">source</a></section></article><h2 id="Signal-Simulation"><a class="docs-heading-anchor" href="#Signal-Simulation">Signal Simulation</a><a id="Signal-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-Simulation" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex" href="#BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex"><code>BlochSimulators._allocate_signal_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_signal_array(resource, trajectory::AbstractTrajectory, coil_sensitivities)</code></pre><p>Allocate an array to store the output of the signal simulation (all readout points, integrated over all voxels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._signal_per_coil!-NTuple{7, Any}" href="#BlochSimulators._signal_per_coil!-NTuple{7, Any}"><code>BlochSimulators._signal_per_coil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_signal_per_coil!(signal, resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Compute the signal for a given coil by calculating a volume integral of the transverse magnetization  in each voxel for each time point separately (using the signal<em>at</em>time_point!` function).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPU1, Any, Any, Any, Any, Any}" href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPU1, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_signal_per_coil!(signal, ::CPU1, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Loop over the time points to calculate the signal at that time point in a serial fashion on a single CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPUThreads, Any, Any, Any, Any, Any}" href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPUThreads, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_signal_per_coil!(signal, ::CPUThreads, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Loop over the time points to calculate the signal at that time point in a multi-threaded fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CUDALibs, Any, Any, Any, Any, Any}" href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CUDALibs, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_signal_per_coil!(signal, ::CUDALibs, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Let different threads of an NVIDIA CUDA device calculate the signal at different time points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-NTuple{6, Any}" href="#BlochSimulators.magnetization_to_signal-NTuple{6, Any}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Allocates memory for the signal and computes the signal for each coil separately using the <code>_signal_per_coil!</code> function. That function is implemented for different computational resources and will be called based on the <code>resource</code> argument. The default implementations loop over all time points and compute the volume integral of the transverse magnetization in each voxel for each time point separately.</p><p>This loop order is not necessarily optimal (and performance may be) across all trajectories and computational resources. If a better implementation is available, add new methods to this function for those specific combinations of resources and trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-Tuple{ComputationalResources.CPUProcesses, DistributedArrays.DArray, DistributedArrays.DArray, Any, DistributedArrays.DArray, DistributedArrays.DArray}" href="#BlochSimulators.magnetization_to_signal-Tuple{ComputationalResources.CPUProcesses, DistributedArrays.DArray, DistributedArrays.DArray, Any, DistributedArrays.DArray, DistributedArrays.DArray}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(::CPUProcesses, dmagnetization, dparameters, trajectory, dcoordinates, dcoil_sensitivities)</code></pre><p>The &quot;voxels&quot; are assumed to be distributed over the workers. Each worker computes performs a volume integral  over the voxels that it owns only (for all time points) using the CPU1() code. The results are then summed up across all workers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}, AbstractTrajectory{T}, AbstractArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}" href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}, AbstractTrajectory{T}, AbstractArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)</code></pre><p>Simulate the MR signal at timepoint <code>t</code> from coil <code>i</code> as: <code>sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t)</code>, where <code>cᵢⱼ</code>is the coil sensitivity of coil <code>i</code> at position of voxel <code>j</code>, <code>ρⱼ</code> is the proton density of voxel <code>j</code> and <code>mⱼ(t)</code> the (normalized) transverse magnetization in voxel <code>j</code> obtained through Bloch simulations.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters}</code>: Vector with tissue parameters for each voxel</li><li><code>trajectory::AbstractTrajectory</code>: Custom trajectory struct</li><li><code>coordinates::AbstractVector{&lt;:Coordinates}</code>: Vector with spatial coordinates for each voxel</li><li><code>coil_sensitivities::AbstractMatrix</code>: Sensitivity of coil <code>j</code> in voxel <code>v</code> is given by <code>coil_sensitivities[v,j]</code></li></ul><p><strong>Returns</strong></p><ul><li><code>signal::AbstractMatrix{&lt;:Complex}</code>: Simulated MR signal for the <code>sequence</code> and <code>trajectory</code>.</li></ul><p>The matrix is of size (# samples, # coils). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/simulate/signal.jl#L1-L20">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f32-Tuple{Any}" href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f32(x)</code></pre><p>Change precision of <code>x</code> to <code>Float32</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/utils/precision.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f64-Tuple{Any}" href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f64(x)</code></pre><p>Change precision of <code>x</code> to <code>Float64</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to <code>adapt_storage</code>) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/utils/precision.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.gpu-Tuple{Any}" href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gpu(x)</code></pre><p>Move <code>x</code> to CUDA device. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>, converting <code>&lt;:AbstractArrays</code> to <code>CuArrays</code>, and ignoring isbitsarrays. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/4b11e118f4cad425ede0492aa469d03e433dfdad/src/utils/gpu.jl#L6-L13">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#BlochSimulators.AbstractTissueParameters"><code>BlochSimulators.AbstractTissueParameters</code></a></li><li><a href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a></li><li><a href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a></li><li><a href="#BlochSimulators.CartesianTrajectory"><code>BlochSimulators.CartesianTrajectory</code></a></li><li><a href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a></li><li><a href="#BlochSimulators.EPGStates"><code>BlochSimulators.EPGStates</code></a></li><li><a href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a></li><li><a href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a></li><li><a href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a></li><li><a href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a></li><li><a href="#BlochSimulators.RadialTrajectory"><code>BlochSimulators.RadialTrajectory</code></a></li><li><a href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a></li><li><a href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a></li><li><a href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a></li><li><a href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a></li><li><a href="#BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}"><code>BlochSimulators._allocate_array_on_resource</code></a></li><li><a href="#BlochSimulators._allocate_magnetization_array-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}}} where {N, T}"><code>BlochSimulators._allocate_magnetization_array</code></a></li><li><a href="#BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex"><code>BlochSimulators._allocate_signal_array</code></a></li><li><a href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPUThreads, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a></li><li><a href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CUDALibs, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a></li><li><a href="#BlochSimulators._signal_per_coil!-NTuple{7, Any}"><code>BlochSimulators._signal_per_coil!</code></a></li><li><a href="#BlochSimulators._signal_per_coil!-Tuple{Any, ComputationalResources.CPU1, Any, Any, Any, Any, Any}"><code>BlochSimulators._signal_per_coil!</code></a></li><li><a href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}"><code>BlochSimulators.add_gradient_delay!</code></a></li><li><a href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a></li><li><a href="#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}"><code>BlochSimulators.decay!</code></a></li><li><a href="#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.dephasing!</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a></li><li><a href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a></li><li><a href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a></li><li><a href="#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.initial_conditions!</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-Tuple{ComputationalResources.CPUProcesses, DistributedArrays.DArray, DistributedArrays.DArray, Any, DistributedArrays.DArray, DistributedArrays.DArray}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, Any, CartesianTrajectory, Any, Any}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-NTuple{6, Any}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a></li><li><a href="#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}"><code>BlochSimulators.regrowth!</code></a></li><li><a href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T"><code>BlochSimulators.rotate!</code></a></li><li><a href="#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a></li><li><a href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_Ω!</code></a></li><li><a href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}"><code>BlochSimulators.sampling_mask</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization!</code></a></li><li><a href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, AbstractVector{&lt;:AbstractTissueParameters{N, T}}, AbstractTrajectory{T}, AbstractArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a></li><li><a href="#BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.spoil!</code></a></li><li><a href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../adiabatic/">« Adiabatic inversion</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 June 2024 08:27">Thursday 6 June 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
