<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BlochSimulators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlochSimulators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../dictionary/">MR Fingerprinting Dictionary Generation</a></li><li><a class="tocitem" href="../signal/">Simulate MR Signal</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Isochromat-Operators"><span>Isochromat Operators</span></a></li><li><a class="tocitem" href="#EPG-Operators"><span>EPG Operators</span></a></li><li><a class="tocitem" href="#Tissue-Parameters"><span>Tissue Parameters</span></a></li><li><a class="tocitem" href="#Sequences"><span>Sequences</span></a></li><li><a class="tocitem" href="#Trajectories"><span>Trajectories</span></a></li><li><a class="tocitem" href="#Dictionary-Simulation"><span>Dictionary Simulation</span></a></li><li><a class="tocitem" href="#Signal-Simulation"><span>Signal Simulation</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Isochromat-Operators"><a class="docs-heading-anchor" href="#Isochromat-Operators">Isochromat Operators</a><a id="Isochromat-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Isochromat-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Isochromat" href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Isochromat{T&lt;:Real} &lt;: FieldVector{3,T}
    x::T
    y::T
    z::T
end</code></pre><p>Holds the x,y,z components of a spin isochromat in a FieldVector, which is a <code>StaticVector</code> (from the package <code>StaticArrays</code>) with custom fieldnames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T" href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay(m::Isochromat{T}, E₁, E₂) where T</code></pre><p>Apply T₂ decay to transverse component and T₁ decay to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T" href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T</code></pre><p>Initialize a spin isochromat to be used throughout a simulation of the sequence.</p><p>This may seem redundant but to is necessary to share the same programming interface with <code>EPGSimulators</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T" href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueParameters) where T</code></pre><p>Invert <code>Isochromat</code> with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T" href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueParameters) where T</code></pre><p>Invert z-component of <code>Isochromat</code> (assuming spoiled transverse magnetization so xy-component zero).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T" href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth(m::Isochromat{T}, E₁) where T</code></pre><p>Apply T₁ regrowth to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}" href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueParameters)</code></pre><p>Rotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T" href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat{T}, γΔtRF::Complex, γΔtGR::Tuple, (x,y,z), Δt, p::AbstractTissueParameters, Δω = zero(T)) where T</code></pre><p>RF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues rotation formula (https://en.wikipedia.org/wiki/Rodrigues%27<em>rotation</em>formula).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample transverse magnetization from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S" href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample m.x, m.y and m.z components from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/isochromat.jl#L156-L161">source</a></section></article><h2 id="EPG-Operators"><a class="docs-heading-anchor" href="#EPG-Operators">EPG Operators</a><a id="EPG-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#EPG-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.EPGStates" href="#BlochSimulators.EPGStates"><code>BlochSimulators.EPGStates</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EPGStates = Union{MMatrix{3}, SizedMatrix{3}}</code></pre><p>In the EPG model, the configuration state matrix <code>Ω</code> will be updated inplace. On CPU, we use <code>StaticArrays.MMatrix</code>. The MMatrix will not escape <code>_simulate!</code> and therefore should not result in allocations. On GPU, we use shared memory (<code>CUDA.CuStaticSharedArray</code>). The shared memory is allocated for all threads within a block simultaneously. We then take a <code>@view</code> and wrap it in a <code>SizedArray</code>. Without the <code>SizedArray</code>, the type would be long and unreadable. By wrapping, we can then simply dispatch on a <code>SizedArray</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F̄₋-Tuple{Any}" href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F̄₋(Ω)</code></pre><p>View into the second row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F̄₋</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F₊-Tuple{Any}" href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F₊(Ω)</code></pre><p>View into the first row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F₊</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Z-Tuple{Any}" href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z(Ω)</code></pre><p>View into the third row of the configuration state matrix <code>Ω</code>, corresponding to the <code>Z</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}" href="#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}"><code>BlochSimulators.decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay!(Ω::EPGStates, E₁, E₂)</code></pre><p>T₂ decay for F-components, T₁ decay for <code>Z</code>-component of each state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.dephasing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dephasing!(Ω::EPGStates)</code></pre><p>Shift states around due to dephasing gradient: The <code>F₊</code> go up one, the <code>F̄₋</code> go down one and <code>Z</code> do not change</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::EPGStates, RF::Complex, p::AbstractTissueParameters)</code></pre><p>Mixing of states due to RF pulse. Magnitude of RF is the flip angle in degrees. Phase of RF is the phase of the pulse. If RF is real, the computations simplify a little bit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::EPGStates, RF::T, p::AbstractTissueParameters) where T&lt;:Union{Real, Quantity{&lt;:Real}}</code></pre><p>If RF is real, the calculations simplify (and probably Ω is real too, reducing memory (access) requirements).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.initial_conditions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_conditions!(Ω::EPGStates)</code></pre><p>Set all components of all states to 0, except the Z-component of the 0th state which is set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an <code>MMatrix</code> of EPG states on CPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an array of EPG states on a CUDA GPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}" href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::EPGStates, p::AbstractTissueParameters)</code></pre><p>Invert <code>Z</code>-component of states of all orders. <em>Assumes fully spoiled transverse magnetization</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::EPGStates)</code></pre><p>Invert with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}" href="#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}"><code>BlochSimulators.regrowth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth!(Ω::EPGStates, E₁)</code></pre><p>T₁ regrowth for Z-component of 0th order state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T" href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T"><code>BlochSimulators.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate!(Ω::EPGStates, eⁱᶿ::T) where T</code></pre><p>Rotate <code>F₊</code> and <code>F̄₋</code> states under the influence of <code>eⁱᶿ = exp(i * ΔB₀ * Δt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}" href="#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_decay!(Ω::EPGStates, E₁, E₂, eⁱᶿ)</code></pre><p>Rotate and decay combined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)</code></pre><p>Sample the measurable transverse magnetization, that is, the <code>F₊</code> component of the 0th state. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L264-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_Ω!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)</code></pre><p>Sample the entire configuration state matrix <code>Ω</code>. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}" href="#BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.spoil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spoil!(Ω::EPGStates)</code></pre><p>Perfectly spoil the transverse components of all states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}" href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}</code></pre><p>By default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/operators/epg.jl#L40-L47">source</a></section></article><h2 id="Tissue-Parameters"><a class="docs-heading-anchor" href="#Tissue-Parameters">Tissue Parameters</a><a id="Tissue-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Tissue-Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTissueParameters" href="#BlochSimulators.AbstractTissueParameters"><code>BlochSimulators.AbstractTissueParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTissueParameters{N,T} &lt;: FieldVector{N,T}</code></pre><p>Abstract type for structs that hold different combinations of tissue parameters.</p><p><strong>Possible fields</strong></p><ul><li><code>T₁::T</code>: T₁ relaxation parameters of a voxel</li><li><code>T₂::T</code>: T₂ relaxation parameters of a voxel</li><li><code>B₁::T</code>: Scaling factor for effective B₁ excitation field within a voxel</li><li><code>B₀::T</code>: Off-resonance with respect to main magnetic field within a voxel</li><li><code>ρˣ::T</code>: Real part of proton density within a voxel</li><li><code>ρʸ::T</code>: Imaginary part of proton density within a voxel</li><li><code>x::T</code>: Position of voxel along the x direction</li><li><code>y::T</code>: Position of voxel along the y direction</li><li><code>z::T</code>: Position of voxel along the z direction</li></ul><p>The structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:</p><ol><li>FieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons</li><li>The named fields improve readability of the code (e.g. <code>p.B₁</code> vs <code>p[3]</code>)</li><li>Linear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/interfaces/tissueparameters.jl#L1-L24">source</a></section></article><h2 id="Sequences"><a class="docs-heading-anchor" href="#Sequences">Sequences</a><a id="Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Sequences" title="Permalink"></a></h2><h4 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.BlochSimulator" href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlochSimulator{T}</code></pre><p>The abstract type of which all sequence simulators will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an <code>AbstractTrajectory</code> will be needed as well.</p><p>To make a simulator for a particular pulse sequence:</p><ol><li><p>Make a struct that&#39;s a subtype of either <code>IsochromatSimulator</code> or <code>EPGSimulator</code>.  The struct will hold parameters that are necessary for performing the simulations.</p></li><li><p>Add a method to <code>simulate_magnetization!</code> that implements the pulse sequence. For both performance and GPU compatibility,  make sure that <code>simulate_magnetization!</code> does not do any heap allocations. Examples for <code>pSSFP</code> and <code>FISP</code>  sequences are found in <code>src/sequences</code>.</p></li><li><p>Add methods to <code>output_eltype</code> and <code>output_size</code> that are used to allocate an output array within the simulate function.</p></li><li><p>[Optional] Add a method to show for nicer printing of the sequence in the REPL</p></li><li><p>[Optional] Add a method to getindex to easily reduce the length of the sequence</p></li><li><p>[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct</p></li></ol><p><strong>IMPORTANT</strong></p><p>The <code>simulate_magnetization!</code> functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from <code>operators/epg.jl</code><code>and</code>operators/isochromat.jl` and a properly parametrized sequence struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/interfaces/sequences.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.IsochromatSimulator" href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsochromatSimulator{T} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/interfaces/sequences.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.EPGSimulator" href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EPGSimulator{T,Ns} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter <code>Ns</code> corresponds to the maximum order of configuration states that are tracked in the simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/interfaces/sequences.jl#L50-L58">source</a></section></article><h4 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h4><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic2D" href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic2D{T,V,M,S} where {T&lt;:AbstractFloat, V&lt;:AbstractVector, M&lt;:AbstractMatrix, S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li><li><code>z::V{T}</code>: Vector with different positions along the slice direction </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/sequences/generic2d.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic3D" href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic3D{T,V&lt;:AbstractVector{Complex{T}},W&lt;:AbstractVector{T},M&lt;:AbstractMatrix{T},S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/sequences/generic3d.jl#L1-L11">source</a></section></article><h2 id="Trajectories"><a class="docs-heading-anchor" href="#Trajectories">Trajectories</a><a id="Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectories" title="Permalink"></a></h2><h4 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTrajectory" href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTrajectory</code></pre><p>The abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/interfaces/trajectories.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.SpokesTrajectory" href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpokesTrajectory &lt;: AbstractTrajectory</code></pre><p>Typical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory such that some methods that would be the same for both trajectories otherwise are written for SpokesTrajectory instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/cartesian.jl#L3-L11">source</a></section></article><h4 id="Interface-2"><a class="docs-heading-anchor" href="#Interface-2">Interface</a><a class="docs-heading-anchor-permalink" href="#Interface-2" title="Permalink"></a></h4><h4 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.CartesianTrajectory" href="#BlochSimulators.CartesianTrajectory"><code>BlochSimulators.CartesianTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CartesianTrajectory{T,I,U,V} &lt;: SpokesTrajectory</code></pre><p>Struct that is used to implement a typical Cartesian gradient trajectory. The trajectory is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δkₓ per sample point (same for all readouts)</li><li><code>py::V</code>: Phase encoding index for each readout</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/cartesian.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}" href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::CartesianTrajectory)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/cartesian.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}" href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}"><code>BlochSimulators.sampling_mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampling_mask(tr::CartesianTrajectory)</code></pre><p>For undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/cartesian.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.RadialTrajectory" href="#BlochSimulators.RadialTrajectory"><code>BlochSimulators.RadialTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialTrajectory{T,I,U,V} &lt;: SpokesTrajectory</code></pre><p>Struct that is used to implement a typical radial gradient trajectory. The trajectory can is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δk between each readout</li><li><code>φ::V</code>: Radial angle for each readout</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/radial.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}" href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}"><code>BlochSimulators.add_gradient_delay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_gradient_delay!(tr::RadialTrajectory, S)</code></pre><p>Apply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/radial.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}" href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::RadialTrajectory)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/examples/trajectories/radial.jl#L114-L118">source</a></section></article><h2 id="Dictionary-Simulation"><a class="docs-heading-anchor" href="#Dictionary-Simulation">Dictionary Simulation</a><a id="Dictionary-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionary-Simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(resource, sequence, parameters)</code></pre><p>Simulate the magnetization at echo times (without any spatial encoding gradients applied) for all combinations of tissue parameters contained in <code>parameters</code>.</p><p>This function can also be used to generate dictionaries for MR Fingerprinting purposes.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters}</code>: Vector with different combinations of tissue parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>output::AbstractArray</code>: Array of size (output_dimensions(sequence), length(parameters)) containing the   magnetization at echo times for all combinations of input tissue parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_output-Tuple{Any, BlochSimulator, Any}" href="#BlochSimulators._allocate_output-Tuple{Any, BlochSimulator, Any}"><code>BlochSimulators._allocate_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_output(resource, sequence::BlochSimulator, parameters)</code></pre><p>Allocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the <code>sequence</code>. For each <code>BlochSimulator</code>, methods should have been added to <code>output_eltype</code> and <code>output_dimensions</code> for this function to work properly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPU1, Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(::CPU1, sequence, parameters)</code></pre><p>Perform simulations on a single CPU by looping over all entries of <code>parameters</code> and performing Bloch simulations for each combination of tissue parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUProcesses, Any, DistributedArrays.DArray}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUProcesses, Any, DistributedArrays.DArray}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(::CPUProcesses, sequence, dparameters::DArray)</code></pre><p>Perform simulations using multiple, distributed CPUs. See the <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">Julia documentation</a> and the <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DistributedArrays</a> package for more details on how to use Julia with multiple workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUThreads, Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUThreads, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(::CPUThreads, sequence, parameters)</code></pre><p>Perform simulations by looping over all entries of <code>parameters</code> in a multi-threaded fashion. See the <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">Julia documentation</a> for more details on how to launch Julia with multiple threads of execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CUDALibs, Any, CUDA.CuArray}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CUDALibs, Any, CUDA.CuArray}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(::CUDALibs, sequence, parameters::CuArray)</code></pre><p>Perform simulations on NVIDIA GPU hardware by making use of the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> package. Each thread perform Bloch simulations for a single entry of the <code>parameters</code> array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/magnetization.jl#L87-L92">source</a></section></article><h2 id="Signal-Simulation"><a class="docs-heading-anchor" href="#Signal-Simulation">Signal Simulation</a><a id="Signal-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-Simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_signal-NTuple{5, Any}" href="#BlochSimulators.simulate_signal-NTuple{5, Any}"><code>BlochSimulators.simulate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)</code></pre><p>Simulate the MR signal at timepoint <code>t</code> from coil <code>i</code> as: <code>sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t)</code>, where <code>cᵢⱼ</code>is the coil sensitivity of coil <code>i</code> at position of voxel <code>j</code>, <code>ρⱼ</code> is the proton density of voxel <code>j</code> and <code>mⱼ(t)</code> the (normalized) transverse magnetization in voxel <code>j</code> obtained through Bloch simulations.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::AbstractVector{&lt;:AbstractTissueParameters}</code>: Vector with tissue parameters for each voxel</li><li><code>trajectory::AbstractTrajectory</code>: Custom trajectory struct</li><li><code>coil_sensitivities::AbstractVector{&lt;:SVector{ncoils}}</code>: Vector with <code>ncoils</code> coil sensitivities for each voxel</li></ul><p><strong>Returns</strong></p><ul><li><code>signal::Vector{&lt;:SVector{ncoils}}</code>: Simulated MR signal for the <code>sequence</code> and <code>trajectory</code>.</li></ul><p>At each timepoint, the signal for each of the <code>ncoils</code> is stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/signal.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_signal_output-Union{Tuple{T}, Tuple{Any, AbstractTrajectory, AbstractVector{T}}} where T&lt;:(StaticArraysCore.SVector)" href="#BlochSimulators._allocate_signal_output-Union{Tuple{T}, Tuple{Any, AbstractTrajectory, AbstractVector{T}}} where T&lt;:(StaticArraysCore.SVector)"><code>BlochSimulators._allocate_signal_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_signal_output(resource, trajectory::AbstractTrajectory, coil_sensitivities)</code></pre><p>Allocate an array to store the output of the signal simulation (all readout points, integrated over all voxels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/signal.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-NTuple{5, Any}" href="#BlochSimulators.magnetization_to_signal-NTuple{5, Any}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(resource, magnetizationtization, parameters, trajectory, coil_sensitivities)</code></pre><p>Given the magnetization in all voxels (typically at echo times only), allocate memory for the signal output on CPU, then loop over all time points <code>t</code> and use the (generic) <code>magnetization_to_signal!</code> implementation to compute the signal for that time point.</p><p>This loop order is not necessarily optimal (and performance may be) across all trajectories and computational resources. If a better implementation is available, add new methods to this function for those specific combinations of resources and trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/simulate/signal.jl#L46-L56">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f32-Tuple{Any}" href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f32(x)</code></pre><p>Change precision of <code>x</code> to <code>Float32</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/utils/precision.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f64-Tuple{Any}" href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f64(x)</code></pre><p>Change precision of <code>x</code> to <code>Float64</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to <code>adapt_storage</code>) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/utils/precision.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.gpu-Tuple{Any}" href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gpu(x)</code></pre><p>Move <code>x</code> to CUDA device. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>, converting <code>&lt;:AbstractArrays</code> to <code>CuArrays</code>, and ignoring isbitsarrays. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/34596e17bf901dbaf6a85eda430b4da971c3f3c4/src/utils/gpu.jl#L6-L13">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#BlochSimulators.AbstractTissueParameters"><code>BlochSimulators.AbstractTissueParameters</code></a></li><li><a href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a></li><li><a href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a></li><li><a href="#BlochSimulators.CartesianTrajectory"><code>BlochSimulators.CartesianTrajectory</code></a></li><li><a href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a></li><li><a href="#BlochSimulators.EPGStates"><code>BlochSimulators.EPGStates</code></a></li><li><a href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a></li><li><a href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a></li><li><a href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a></li><li><a href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a></li><li><a href="#BlochSimulators.RadialTrajectory"><code>BlochSimulators.RadialTrajectory</code></a></li><li><a href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a></li><li><a href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a></li><li><a href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a></li><li><a href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a></li><li><a href="#BlochSimulators._allocate_output-Tuple{Any, BlochSimulator, Any}"><code>BlochSimulators._allocate_output</code></a></li><li><a href="#BlochSimulators._allocate_signal_output-Union{Tuple{T}, Tuple{Any, AbstractTrajectory, AbstractVector{T}}} where T&lt;:(StaticArraysCore.SVector)"><code>BlochSimulators._allocate_signal_output</code></a></li><li><a href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}"><code>BlochSimulators.add_gradient_delay!</code></a></li><li><a href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a></li><li><a href="#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any}"><code>BlochSimulators.decay!</code></a></li><li><a href="#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.dephasing!</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a></li><li><a href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a></li><li><a href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a></li><li><a href="#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.initial_conditions!</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, AbstractTissueParameters}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-NTuple{5, Any}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a></li><li><a href="#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any}"><code>BlochSimulators.regrowth!</code></a></li><li><a href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters, Any}} where T"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, T}} where T"><code>BlochSimulators.rotate!</code></a></li><li><a href="#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a></li><li><a href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.sample_Ω!</code></a></li><li><a href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}"><code>BlochSimulators.sampling_mask</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUProcesses, Any, DistributedArrays.DArray}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CPUThreads, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.CUDALibs, Any, CUDA.CuArray}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_signal-NTuple{5, Any}"><code>BlochSimulators.simulate_signal</code></a></li><li><a href="#BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData&lt;:AbstractArray{T, M}}}}"><code>BlochSimulators.spoil!</code></a></li><li><a href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../signal/">« Simulate MR Signal</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 29 November 2023 13:13">Wednesday 29 November 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
