<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BlochSimulators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlochSimulators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../dictionary/">MR Fingerprinting Dictionary Generation</a></li><li><a class="tocitem" href="../signal/">Simulate MR Signal</a></li><li><a class="tocitem" href="../adiabatic/">Adiabatic inversion</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Isochromat-Operators"><span>Isochromat Operators</span></a></li><li><a class="tocitem" href="#EPG-Operators"><span>EPG Operators</span></a></li><li><a class="tocitem" href="#Tissue-Parameters"><span>Tissue Parameters</span></a></li><li><a class="tocitem" href="#Sequences"><span>Sequences</span></a></li><li><a class="tocitem" href="#Trajectories"><span>Trajectories</span></a></li><li><a class="tocitem" href="#Dictionary-Simulation"><span>Dictionary Simulation</span></a></li><li><a class="tocitem" href="#Signal-Simulation"><span>Signal Simulation</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Isochromat-Operators"><a class="docs-heading-anchor" href="#Isochromat-Operators">Isochromat Operators</a><a id="Isochromat-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Isochromat-Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Isochromat" href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Isochromat{T&lt;:Real} &lt;: FieldVector{3,T}
    x::T
    y::T
    z::T
end</code></pre><p>Holds the x,y,z components of a spin isochromat in a FieldVector, which is a <code>StaticVector</code> (from the package <code>StaticArrays</code>) with custom fieldnames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T" href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay(m::Isochromat{T}, E₁, E₂) where T</code></pre><p>Apply T₂ decay to transverse component and T₁ decay to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T" href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T</code></pre><p>Initialize a spin isochromat to be used throughout a simulation of the sequence.</p><p>This may seem redundant but to is necessary to share the same programming interface with <code>EPGSimulators</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T" href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueProperties) where T</code></pre><p>Invert <code>Isochromat</code> with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueProperties}} where T" href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueProperties}} where T"><code>BlochSimulators.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert(m::Isochromat{T}, p::AbstractTissueProperties) where T</code></pre><p>Invert z-component of <code>Isochromat</code> (assuming spoiled transverse magnetization so xy-component zero).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T" href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth(m::Isochromat{T}, E₁) where T</code></pre><p>Apply T₁ regrowth to longitudinal component of <code>Isochromat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueProperties}" href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueProperties}"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueProperties)</code></pre><p>Rotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties, Any}} where T" href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties, Any}} where T"><code>BlochSimulators.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(m::Isochromat{T}, γΔtRF, γΔtGR, r, Δt, p::AbstractTissueProperties, ΔtΔω=zero(T)) where T</code></pre><p>RF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues&#39; rotation formula.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Input isochromat state.</li><li><code>γΔtRF</code>: Complex value representing RF pulse effect (radians). <code>B₁</code> scaling from <code>p</code> is applied internally if <code>hasB₁(p)</code>.</li><li><code>γΔtGR</code>: Tuple/Vector representing gradient effect <code>γ * G * Δt</code> (radians/centimeter).</li><li><code>r</code>: Position vector <code>(x,y,z)</code> [cm].</li><li><code>Δt</code>: Time step duration (seconds).</li><li><code>p</code>: Tissue properties (<code>AbstractTissueProperties</code>). <code>B₀</code> effects from <code>p</code> are applied internally if <code>hasB₀(p)</code>.</li><li><code>ΔtΔω</code>: Additional off-resonance phase accumulated during <code>Δt</code> (radians). Often <code>Δt * Δω</code>, where <code>Δω</code> is in rad/s.</li></ul><p><strong>Returns</strong></p><ul><li>Rotated isochromat state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample transverse magnetization from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S" href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)</code></pre><p>Sample m.x, m.y and m.z components from <code>Isochromat</code>. The &quot;+=&quot; is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/isochromat.jl#L174-L179">source</a></section></article><h2 id="EPG-Operators"><a class="docs-heading-anchor" href="#EPG-Operators">EPG Operators</a><a id="EPG-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#EPG-Operators" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>EPGStates</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F̄₋-Tuple{Any}" href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F̄₋(Ω)</code></pre><p>View into the second row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F̄₋</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.F₊-Tuple{Any}" href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F₊(Ω)</code></pre><p>View into the first row of the configuration state matrix <code>Ω</code>, corresponding to the <code>F₊</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Z-Tuple{Any}" href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Z(Ω)</code></pre><p>View into the third row of the configuration state matrix <code>Ω</code>, corresponding to the <code>Z</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any}" href="#BlochSimulators.decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any}"><code>BlochSimulators.decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decay!(Ω::AbstractConfigurationStates, E₁, E₂)</code></pre><p>Apply T₁ and T₂ relaxation effects to the EPG states <code>Ω</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>E₁</code>: T₁ relaxation factor, <code>exp(-Δt/T₁)</code>, where <code>Δt</code> is the time duration (seconds) and <code>T₁</code> is from the tissue properties (seconds).</li><li><code>E₂</code>: T₂ relaxation factor, <code>exp(-Δt/T₂)</code>, where <code>Δt</code> is the time duration (seconds) and <code>T₂</code> is from the tissue properties (seconds).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L246-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.dephasing!-Tuple{BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.dephasing!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.dephasing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dephasing!(Ω::AbstractConfigurationStates)</code></pre><p>Shift states around due to dephasing gradient: The <code>F₊</code> go up one, the <code>F̄₋</code> go down one and <code>Z</code> do not change</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L368-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.diffuse!-Tuple{Any, Any}" href="#BlochSimulators.diffuse!-Tuple{Any, Any}"><code>BlochSimulators.diffuse!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>diffuse!(Ω::AbstractConfigurationStatestates, diffusion_decay)</p><p>Apply diffusion decay according to state number by element-wise multiplication with the pre-computed diffusion decay matrix.</p><ul><li><code>Ω</code>: The configuration state matrix</li><li><code>diffusion_decay</code>: The pre-calculated diffusion decay terms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L330-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T&lt;:Real" href="#BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T&lt;:Real"><code>BlochSimulators.diffusion_decay_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diffusion_decay_matrix(Ω::EPGSAbstractConfigurationStatestates, D)</code></pre><p>Pre-calculate diffusion decay according to state number. Store in a matrix with the same size/type as Ω s.t. later on the decay can be applied by element-wise multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix</li><li><code>D</code>: The diffusion coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L279-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.ConfigurationStatesSubset, T}} where T&lt;:Real" href="#BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.ConfigurationStatesSubset, T}} where T&lt;:Real"><code>BlochSimulators.diffusion_decay_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>On GPU, when each thread only holds parts of the configuration state matrix, each thread only computes the corresponding columns of the diffusion decay matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L308-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::AbstractConfigurationStates, RF, p::AbstractTissueProperties)</code></pre><p>Apply RF pulse rotation to the EPG states <code>Ω</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>RF</code>: Complex RF pulse value. <code>abs(RF)</code> is the flip angle (degrees), <code>angle(RF)</code> is the pulse phase (radians). <code>B₁</code> scaling from <code>p</code> is applied internally if <code>hasB₁(p)</code>.</li><li><code>p</code>: Tissue properties (<code>AbstractTissueProperties</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}" href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">excite!(Ω::AbstractConfigurationStates, RF, p::AbstractTissueProperties) where {T&lt;:Union{Real, Quantity{&lt;:Real}}}</code></pre><p>Apply RF pulse rotation to the EPG states <code>Ω</code> (version for real-valued RF pulse, assuming zero phase).</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>RF</code>: Real RF pulse value representing the flip angle (degrees). <code>B₁</code> scaling from <code>p</code> is applied internally if <code>hasB₁(p)</code>.</li><li><code>p</code>: Tissue properties (<code>AbstractTissueProperties</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initial_conditions!-Tuple{BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.initial_conditions!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.initial_conditions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_conditions!(Ω::AbstractConfigurationStates)</code></pre><p>Set all components of all states to 0, except the Z-component of the 0th state which is set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an <code>MMatrix</code> of EPG states on CPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}" href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}</code></pre><p>Initialize an array of EPG states on a CUDA GPU to be used throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates, AbstractTissueProperties}" href="#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates, AbstractTissueProperties}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::AbstractConfigurationStates, p::AbstractTissueProperties)</code></pre><p>Invert <code>Z</code>-component of states of all orders. <em>Assumes fully spoiled transverse magnetization</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L453-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.invert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invert!(Ω::AbstractConfigurationStates)</code></pre><p>Invert with B₁ insenstive (i.e. adiabatic) inversion pulse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.regrowth!-Tuple{BlochSimulators.AbstractConfigurationStates, Any}" href="#BlochSimulators.regrowth!-Tuple{BlochSimulators.AbstractConfigurationStates, Any}"><code>BlochSimulators.regrowth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrowth!(Ω::AbstractConfigurationStates, E₁)</code></pre><p>Apply T₁ regrowth to the longitudinal magnetization equilibrium state (<code>Z₀</code>).</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>E₁</code>: T₁ relaxation factor, <code>exp(-Δt/T₁)</code>, where <code>Δt</code> is the time duration (seconds) and <code>T₁</code> is from the tissue properties (seconds). The regrowth amount is <code>(1 - E₁)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L346-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T" href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T"><code>BlochSimulators.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate!(Ω::AbstractConfigurationStates, eⁱᶿ)</code></pre><p>Apply phase accrual due to off-resonance to the transverse EPG states (<code>F₊</code>, <code>F̄₋</code>).</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>eⁱᶿ</code>: Complex rotation factor, typically <code>exp(im * Δω * Δt)</code>, where <code>Δω</code> is the off-resonance frequency (rad/s, potentially derived from <code>p.B₀</code>) and <code>Δt</code> is the time duration (seconds).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L229-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.rotate_decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any, Any}" href="#BlochSimulators.rotate_decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_decay!(Ω::AbstractConfigurationStates, E₁, E₂, eⁱᶿ)</code></pre><p>Apply combined off-resonance rotation and T₁/T₂ relaxation to the EPG states <code>Ω</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Ω</code>: The configuration state matrix.</li><li><code>E₁</code>: T₁ relaxation factor (<code>exp(-Δt/T₁)</code>).</li><li><code>E₂</code>: T₂ relaxation factor (<code>exp(-Δt/T₂)</code>).</li><li><code>eⁱᶿ</code>: Complex off-resonance rotation factor (<code>exp(im * Δω * Δt)</code>). (See <code>rotate!</code> and</li></ul><p><code>decay!</code> for details on arguments).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.sample_transverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::AbstractConfigurationStates)</code></pre><p>Sample the measurable transverse magnetization, that is, the <code>F₊</code> component of the 0th state. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L489-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.sample_Ω!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::AbstractConfigurationStates)</code></pre><p>Sample the entire configuration state matrix <code>Ω</code>. The <code>+=</code> is needed for 2D sequences where slice profile is taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L505-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.spoil!-Tuple{BlochSimulators.AbstractConfigurationStates}" href="#BlochSimulators.spoil!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.spoil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spoil!(Ω::AbstractConfigurationStates)</code></pre><p>Perfectly spoil the transverse components of all states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}" href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}</code></pre><p>By default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/operators/epg.jl#L65-L72">source</a></section></article><h2 id="Tissue-Parameters"><a class="docs-heading-anchor" href="#Tissue-Parameters">Tissue Parameters</a><a id="Tissue-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Tissue-Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTissueProperties" href="#BlochSimulators.AbstractTissueProperties"><code>BlochSimulators.AbstractTissueProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTissueProperties{N,T} &lt;: FieldVector{N,T}</code></pre><p>Abstract type for custom structs that hold tissue properties used for a simulation within one voxel. For simulations, <code>SimulationParameters</code>s are used that can be assembled with the <code>@parameters</code> macro.</p><p><strong>Possible fields:</strong></p><ul><li><code>T₁::T</code>: Longitudinal relaxation time constant (in seconds).</li><li><code>T₂::T</code>: Transverse relaxation time constant (in seconds).</li><li><code>B₁::T</code>: Relative transmit B₁ field scaling factor (unitless).</li><li><code>B₀::T</code>: Off-resonance frequency (in Hz).</li><li><code>D::T</code>:  Diffusion value: the TR/TD as used in https://doi.org/10.1002/nbm.5044            (in this context it is unitless: &quot;the amount of dispersion per TR at state=1&quot;)</li><li><code>ρˣ::T</code>: Real part of proton density or equilibrium magnetization M₀ (arbitrary units).</li><li><code>ρʸ::T</code>: Imaginary part of proton density or equilibrium magnetization M₀ (arbitrary units).</li></ul><p><strong>Implementation details:</strong></p><p>The structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:</p><ol><li>FieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons</li><li>The named fields improve readability of the code (e.g. <code>p.B₁</code> vs <code>p[3]</code>)</li><li>Linear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/interfaces/tissueproperties.jl#L1-L30">source</a></section></article><h2 id="Sequences"><a class="docs-heading-anchor" href="#Sequences">Sequences</a><a id="Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Sequences" title="Permalink"></a></h2><h4 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.BlochSimulator" href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlochSimulator{T}</code></pre><p>The abstract type of which all sequence simulators will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an <code>AbstractTrajectory</code> will be needed as well.</p><p>To make a simulator for a particular pulse sequence:</p><ol><li><p>Make a struct that&#39;s a subtype of either <code>IsochromatSimulator</code> or <code>EPGSimulator</code>.  The struct will hold parameters that are necessary for performing the simulations.</p></li><li><p>Add a method to <code>simulate_magnetization!</code> that implements the pulse sequence. For both performance and GPU compatibility,  make sure that <code>simulate_magnetization!</code> does not do any heap allocations. Examples for <code>pSSFP</code> and <code>FISP</code>  sequences are found in <code>src/sequences</code>.</p></li><li><p>Add methods to <code>output_eltype</code> and <code>output_size</code> that are used to allocate an output array within the simulate function.</p></li><li><p>[Optional] Add a method to show for nicer printing of the sequence in the REPL</p></li><li><p>[Optional] Add a method to getindex to easily reduce the length of the sequence</p></li><li><p>[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct</p></li></ol><p><strong>IMPORTANT</strong></p><p>The <code>simulate_magnetization!</code> functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from <code>operators/epg.jl</code><code>and</code>operators/isochromat.jl` and a properly parametrized sequence struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/interfaces/sequences.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.IsochromatSimulator" href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsochromatSimulator{T} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/interfaces/sequences.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.EPGSimulator" href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EPGSimulator{T,Ns} &lt;: BlochSimulator{T}</code></pre><p>Abstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter <code>T</code> should be a number type (e.g. <code>Float64</code>, <code>Float32</code>) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter <code>Ns</code> corresponds to the maximum order of configuration states that are tracked in the simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/interfaces/sequences.jl#L50-L58">source</a></section></article><h4 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h4><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic2D" href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic2D{T,V,M,S} where {T&lt;:AbstractFloat, V&lt;:AbstractVector, M&lt;:AbstractMatrix, S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li><li><code>z::V{T}</code>: Vector with different positions along the slice direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/sequences/generic2d.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.Generic3D" href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generic3D{T,V&lt;:AbstractVector{Complex{T}},W&lt;:AbstractVector{T},M&lt;:AbstractMatrix{T},S} &lt;: IsochromatSimulator{T}</code></pre><p>Simulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.</p><p><strong>Fields</strong></p><ul><li><code>RF::V{Complex{T}}</code>: Vector with (complex) RF values during each time interval</li><li><code>GR::M{T}</code>: Matrix with GRx, GRy and GRz values during each time interval</li><li><code>sample::S</code>: Vector with Bool&#39;s to indicate the sample points</li><li><code>Δt::V{T}</code>: Vector with time intervals</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/sequences/generic3d.jl#L1-L11">source</a></section></article><h2 id="Trajectories"><a class="docs-heading-anchor" href="#Trajectories">Trajectories</a><a id="Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectories" title="Permalink"></a></h2><h4 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.AbstractTrajectory" href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTrajectory{T}</code></pre><p>The abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence. The type T refers to the precision of the floating point values within the trajectory struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/interfaces/trajectories.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.SpokesTrajectory" href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpokesTrajectory{T} &lt;: AbstractTrajectory{T}</code></pre><p>Typical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory such that some methods that would be the same for both trajectories otherwise are written for SpokesTrajectory instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/_abstract.jl#L1-L9">source</a></section></article><h4 id="Interface-2"><a class="docs-heading-anchor" href="#Interface-2">Interface</a><a class="docs-heading-anchor-permalink" href="#Interface-2" title="Permalink"></a></h4><h4 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.CartesianTrajectory2D" href="#BlochSimulators.CartesianTrajectory2D"><code>BlochSimulators.CartesianTrajectory2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CartesianTrajectory2D{T,I,U,V} &lt;: CartesianTrajectory{T}</code></pre><p>Struct that is used to implement a typical Cartesian 2D gradient trajectory. The trajectory is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory2D and RadialTrajectory2D are essentially the same when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δkₓ per sample point (same for all readouts)</li><li><code>py::V</code>: Phase encoding index for each readout</li><li><code>readout_oversampling::I</code>: Readout oversampling factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/cartesian.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory2D}" href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory2D}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::CartesianTrajectory2D)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/cartesian.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, StructArrays.StructArray{&lt;:AbstractTissueProperties}, CartesianTrajectory2D, StructArrays.StructArray{&lt;:Coordinates}, Any}" href="#BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, StructArrays.StructArray{&lt;:AbstractTissueProperties}, CartesianTrajectory2D, StructArrays.StructArray{&lt;:Coordinates}, Any}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(::Union{CPU1,CPUThreads,CUDALibs}, magnetization, parameters, trajectory::CartesianTrajectory2D, coordinates, coil_sensitivities)</code></pre><p><strong>Arguments</strong></p><ul><li><code>magnetization</code>:          Matrix{Complex} of size (# readouts, # voxels) with phase-encoded                   magnetization at echo times.</li><li><code>parameters</code>:     Tissue parameters of all voxels, including spatial coordinates.</li><li><code>trajectory</code>:     Cartesian trajectory struct.</li><li><code>coordinates</code>:    Vector{Coordinates} with spatial coordinates for each voxel.</li><li><code>coil_sensitivities</code>:     Matrix{Complex} of size (# voxels, # coils) with coil sensitivities.</li></ul><p><strong>Returns</strong></p><ul><li><code>signal</code>: Vector of length (# coils) with each element a Matrix{Complex}       of size (# readouts, # samples per readout)</li></ul><p><strong>Extended help</strong></p><p>As noted in the description of the simulate_signal function (see <code>src/simulate/signal.jl</code>), we simulate the MR signal at timepoint <code>t</code> from coil <code>i</code> as: signalᵢ[t] = sum(m[t,v] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)), where <code>cᵢ</code>is the coil sensitivity profile of coil <code>i</code>, <code>ρ</code> is the proton density map and <code>m</code> the matrix with the magnetization at all timepoints for each voxel obtained through Bloch simulations.</p><p>The output (signalᵢ) for each coil is in principle a <code>Vector{Complex}</code><code>of length (# samples per readout) * (# readouts). If we reshape the output into a</code>Matrix{Complex}<code>of size (# samples per readout, # readouts) instead, and do something similar for</code>m`, then the signal value associated with the s-th sample point of the r-th readout can be expressed as signalᵢ[r,s] = sum( m[r,s,v]] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)).</p><p>The problem here is that we typically cannot store the full m. Instead, we compute the magnetization at echo times only. The reason is that, if mᵣ is the magnetization at the r-th echo time in some voxel, and E = exp(-Δt<em>R₂[v]) * exp(im</em>(Δkₓ*x[v])) is the change per sample point (WHICH FOR CARTESIAN SEQUENCES IS THE SAME FOR ALL READOUTS AND SAMPLES), then the magnetization at the s-th sample relative the the echo time can can be computed as mₛ = mᵣ * E[v]^s</p><p>Therefore we can write</p><p>signalⱼ[r,s] = sum( magnetization[r,v] * E[v]^s * ρ[v] * cⱼ[v] for v in 1:(# voxels)) signalⱼ[r,s] = magnetization[r,:] * (E.^s .* ρ .* cⱼ)</p><p>Because the (E.^s .* ρ .* cⱼ)-part is the same for all readouts, we can simply perform this computation for all readouts simultaneously as signalⱼ[:,s] = magnetization * (E.^s .* ρ .* cⱼ)</p><p>If we define the matrix Eˢ as E .^ (-(ns÷2):(ns÷2)-1), then we can do the computation for all different sample points at the same time as well using a single matrix-matrix multiplication: signalⱼ = magnetization * (Eˢ .* (ρ .* cⱼ))</p><p>The signalⱼ array is of size (# readouts, # samples per readout). We prefer to have it transposed, therefore we compute signalⱼ = transpose(Eˢ .* (ρ .* cⱼ)) * transpose(magnetization) instead.</p><p>For the final output, we do this calculation for each coil j and get a vector of signal matrices (one matrix for each coil) as a result.</p><p>Note that this implementation relies entirely on vectorized code and works on both CPU and GPU. The matrix-matrix multiplications are - I think - already multi-threaded so a separate multi-threaded implementation is not needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/cartesian.jl#L41-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.sampling_mask-Tuple{CartesianTrajectory2D}" href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory2D}"><code>BlochSimulators.sampling_mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampling_mask(tr::CartesianTrajectory2D)</code></pre><p>For undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/cartesian.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.RadialTrajectory2D" href="#BlochSimulators.RadialTrajectory2D"><code>BlochSimulators.RadialTrajectory2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialTrajectory2D{T,I,U,V} &lt;: SpokesTrajectory{T}</code></pre><p>Struct that is used to implement a typical radial gradient trajectory. The trajectory can is described in a compact fashion by only storing the starting position in k-space (<code>k_start_readout</code>) for each readout as well as the step in k-space per readout point <code>Δk_adc</code>.</p><p>Note that CartesianTrajectory2D and RadialTrajectory2D are essentially the same when using this compact description. A SpokesTrajectory struct is therefore  defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.</p><p>The type parameters are intentionally left vague. The <code>J</code>, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.</p><p><strong>Fields</strong></p><ul><li><code>nreadouts::I</code>: The total number of readouts for this trajectory</li><li><code>nsamplesperreadout::I</code>: The total number of samples per readout</li><li><code>Δt::T</code>: Time between sample points</li><li><code>k_start_readout::U</code>: Starting position in k-space for each readout</li><li><code>Δk_adc::U</code>: k-space step Δk between each readout</li><li><code>φ::V</code>: Radial angle for each readout</li><li><code>readout_oversampling::I</code>: Readout oversampling factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/radial.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory2D, Any}" href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory2D, Any}"><code>BlochSimulators.add_gradient_delay!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_gradient_delay!(tr::RadialTrajectory2D, S)</code></pre><p>Apply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/radial.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory2D}" href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory2D}"><code>BlochSimulators.kspace_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_coordinates(tr::RadialTrajectory2D)</code></pre><p>Return matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/trajectories/radial.jl#L113-L117">source</a></section></article><h2 id="Dictionary-Simulation"><a class="docs-heading-anchor" href="#Dictionary-Simulation">Dictionary Simulation</a><a id="Dictionary-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionary-Simulation" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simulate_magnetization(resource, sequence, parameters)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}" href="#BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}"><code>BlochSimulators._allocate_array_on_resource</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_array_on_resource(resource, _eltype, _size)</code></pre><p>Allocate an array on the specified <code>resource</code> with the given element type <code>_eltype</code> and size <code>_size</code>. If <code>resource</code> is <code>CPU1()</code> or <code>CPUThreads()</code>, the array is allocated on the CPU. If <code>resource</code> is <code>CUDALibs()</code>, the array is allocated on the GPU. For <code>CPUProcesses()</code>, the array is distributed in the &quot;voxel&quot;-dimension over multiple CPU workers.</p><p>This function is called by <code>_allocate_magnetization_array</code> and is not intended considered part of te public API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L201-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_magnetization_array-Tuple{Any, Any, Any}" href="#BlochSimulators._allocate_magnetization_array-Tuple{Any, Any, Any}"><code>BlochSimulators._allocate_magnetization_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_magnetization_array(resource, sequence, parameters)</code></pre><p>Allocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the <code>sequence</code>. For each <code>BlochSimulator</code>, methods should have been added to <code>output_eltype</code> and <code>output_size</code> for this function to work properly.</p><p>This function is called by <code>simulate_magnetization</code> and is not intended considered part of te public API.</p><p><strong>Returns</strong></p><ul><li><code>magnetization_array</code>: An array allocated on the specified <code>resource</code>, formatted to store the simulation results for each voxel across the specified echo times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L179-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}" href="#BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization!(magnetization, resource, sequence, parameters)</code></pre><p>Simulate the magnetization response for all combinations of tissue properties contained in <code>parameters</code> and stores the results in the pre-allocated <code>magnetization</code> array. The actual implementation depends on the computational resource specified in <code>resource</code>.</p><p>This function is called by <code>simulate_magnetization</code> and is not intended considered part of te public API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L109-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, AbstractTissueProperties}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, AbstractTissueProperties}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the tissue properties for a single voxel are provided only, the simulation is performed on the CPU in a single-threaded fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, Any}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If no <code>resource</code> is provided, the simulation is performed on the CPU in a multi-threaded fashion by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, CUDA.CuArray}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, CUDA.CuArray}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>However, if the <code>parameters</code> are a CuArray, the simulation is performed on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{Any, DistributedArrays.DArray}" href="#BlochSimulators.simulate_magnetization-Tuple{Any, DistributedArrays.DArray}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the <code>parameters</code> are a DArray, the simulation is performed on the multiple workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{BlochSimulator, StructArrays.StructArray}" href="#BlochSimulators.simulate_magnetization-Tuple{BlochSimulator, StructArrays.StructArray}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_magnetization(sequence, parameters)</code></pre><p>Convenience function to simulate magnetization without specifying the computational resource. The function automatically selects the appropriate resource based on the type of the <code>sequence</code> and <code>parameters</code>. The fallback case is to use multi-threaded CPU computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:AbstractTissueProperties}}" href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:AbstractTissueProperties}}"><code>BlochSimulators.simulate_magnetization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_magnetization(resource, sequence, parameters)</code></pre><p>Simulate the magnetization response (typically the transverse magnetization at echo times without any spatial encoding gradients applied) for all combinations of tissue properties contained in <code>parameters</code>.</p><p>This function can also be used to generate dictionaries for MR Fingerprinting purposes.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::SimulationParameters</code>: Array (typically a <code>StructArray</code>) containing <a href="#BlochSimulators.AbstractTissueProperties"><code>AbstractTissueProperties</code></a> for each voxel. Ensure tissue properties (like <code>T₁</code>, <code>T₂</code>, <code>B₀</code>) use the units specified in the <code>AbstractTissueProperties</code> docstring (e.g., seconds for relaxation times, Hz for off-resonance).</li></ul><p><strong>Note</strong></p><ul><li>If <code>resource == CUDALibs()</code>, the sequence and parameters must have been moved to the GPU using <code>gpu(sequence)</code> and <code>gpu(parameters)</code> prior to calling this function.</li><li>If <code>resource == CPUProcesses()</code>, the parameters must be a <code>DArray</code> with the first dimension corresponding to the number of workers. The function will distribute the simulation across the workers in the first dimension of the <code>DArray</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>magnetization::AbstractArray</code>: Array of size (output_size(sequence), length(parameters)) containing the magnetization response of the sequence for all combinations of input tissue properties.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/magnetization.jl#L1-L30">source</a></section></article><h2 id="Signal-Simulation"><a class="docs-heading-anchor" href="#Signal-Simulation">Signal Simulation</a><a id="Signal-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-Simulation" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex" href="#BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex"><code>BlochSimulators._allocate_signal_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_signal_array(resource, trajectory::AbstractTrajectory, coil_sensitivities)</code></pre><p>Allocate an array to store the output of the signal simulation (all readout points, integrated over all voxels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._signal_per_coil!-NTuple{7, Any}" href="#BlochSimulators._signal_per_coil!-NTuple{7, Any}"><code>BlochSimulators._signal_per_coil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_signal_per_coil!(signal, resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Compute the signal for a given coil by calculating a volume integral of the transverse magnetization in each voxel for each time point separately (using the <code>signal_at_time_point!</code> function). Each time point is computed in parallel for multi-threaded CPU computation and on the GPU for CUDA computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.magnetization_to_signal-NTuple{6, Any}" href="#BlochSimulators.magnetization_to_signal-NTuple{6, Any}"><code>BlochSimulators.magnetization_to_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetization_to_signal(resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Allocates memory for the signal and computes the signal for each coil separately using the <code>_signal_per_coil!</code> function.</p><p><strong>Implementation details</strong></p><p>The <code>_signal_per_coil!</code> function has different implementations depending on the computational resources (i.e. the type of <code>resource</code>). The default implementations loop over all time points and compute the volume integral of the transverse magnetization in each voxel for each time point separately. This loop order is not necessarily optimal (and performance may be) across all trajectories and computational resources. If a better implementation is available, add new methods to this function for those specific combinations of resources and trajectories.</p><p>The &quot;voxels&quot; are assumed to be distributed over the workers. Each worker computes performs a volume integral over the voxels that it owns only (for all time points) using the CPU1() code. The results are then summed up across all workers.</p><p><strong>Note</strong></p><p>When using multiple CPU&#39;s, the &quot;voxels&quot; are distributed over the workers. Each worker computes the signal for its own voxels in parallel and the results are summed up across all workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L52-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_signal-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:StructArrays.StructArray{&lt;:AbstractTissueProperties}}, AbstractTrajectory, AbstractVector{&lt;:StructArrays.StructArray{&lt;:Coordinates}}, AbstractVector{&lt;:AbstractMatrix{&lt;:Complex}}}" href="#BlochSimulators.simulate_signal-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:StructArrays.StructArray{&lt;:AbstractTissueProperties}}, AbstractTrajectory, AbstractVector{&lt;:StructArrays.StructArray{&lt;:Coordinates}}, AbstractVector{&lt;:AbstractMatrix{&lt;:Complex}}}"><code>BlochSimulators.simulate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_signal(sequence, partitioned_parameters::AbstractVector{&lt;:SimulationParameters})</code></pre><p>In situations where the number of voxels is too large to store the intermediate <code>magnetization</code> array, the signal can be calculated in batches: the voxels are divided (by the user) into partitions and the signal is calculated for each partition separately. The final signal is the sum of the signals from all partitions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L245-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{Any, BlochSimulator, AbstractArray{&lt;:AbstractTissueProperties{N, T}}, Any, Any}} where {N, T}" href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{Any, BlochSimulator, AbstractArray{&lt;:AbstractTissueProperties{N, T}}, Any, Any}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>When coil sensitivities are not provided, use a single coil with sensitivity = 1 everywhere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, StructArrays.StructArray{&lt;:AbstractTissueProperties{N, T}}, AbstractTrajectory{T}, StructArrays.StructArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}" href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, StructArrays.StructArray{&lt;:AbstractTissueProperties{N, T}}, AbstractTrajectory{T}, StructArrays.StructArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_signal(resource, sequence, parameters, trajectory, coordinates, coil_sensitivities)</code></pre><p>Simulate the MR signal at timepoint <code>t</code> from coil <code>i</code> as: <code>sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t)</code>, where <code>cᵢⱼ</code> is the coil sensitivity of coil <code>i</code> at the position of voxel <code>j</code>, <code>ρⱼ</code> is the proton density of voxel <code>j</code>, and <code>mⱼ(t)</code> is the (normalized) transverse magnetization in voxel <code>j</code> obtained through Bloch simulations.</p><p><strong>Arguments</strong></p><ul><li><code>resource::AbstractResource</code>: Either <code>CPU1()</code>, <code>CPUThreads()</code>, <code>CPUProcesses()</code> or <code>CUDALibs()</code></li><li><code>sequence::BlochSimulator</code>: Custom sequence struct</li><li><code>parameters::SimulationParameters</code>: Array (typically a <code>StructArray</code>) containing <a href="#BlochSimulators.AbstractTissueProperties"><code>AbstractTissueProperties</code></a> for each voxel. <strong>Must</strong> include proton density fields (<code>ρˣ</code>, <code>ρʸ</code>). Ensure tissue properties (like <code>T₁</code>, <code>T₂</code>, <code>B₀</code>) use the units specified in the <code>AbstractTissueProperties</code> docstring (e.g., seconds for relaxation times, Hz for off-resonance).</li><li><code>trajectory::AbstractTrajectory</code>: Custom trajectory struct</li><li><code>coordinates::StructArray{&lt;:Coordinates}</code>: Array with spatial coordinates for each voxel</li><li><code>coil_sensitivities::AbstractMatrix</code>: Sensitivity of coil <code>j</code> in voxel <code>v</code> is given by <code>coil_sensitivities[v,j]</code></li></ul><p><strong>Returns</strong></p><ul><li><code>signal::AbstractArray{&lt;:Complex}</code>: Simulated MR signal for the <code>sequence</code> and <code>trajectory</code>. The array is of size (# samples per readout, # readouts, # coils).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/simulate/signal.jl#L1-L26">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f32-Tuple{Any}" href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f32(x)</code></pre><p>Change precision of <code>x</code> to <code>Float32</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/utils/precision.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.f64-Tuple{Any}" href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f64(x)</code></pre><p>Change precision of <code>x</code> to <code>Float64</code>. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p><p>It may be necessary to add new adapt rules (by adding new methods to <code>adapt_storage</code>) if new structs with complicated nested fields are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/utils/precision.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators._all_arrays_are_cuarrays-Tuple{Any}" href="#BlochSimulators._all_arrays_are_cuarrays-Tuple{Any}"><code>BlochSimulators._all_arrays_are_cuarrays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_all_arrays_are_cuarrays(x)</code></pre><p>Returns <code>true</code> if all <code>AbstractArray</code> fields in <code>x</code> are <code>CuArray</code>s and <code>false</code> otherwise. Will also <code>return</code> if <code>x</code> does not have any <code>AbstractArray</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/utils/gpu.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BlochSimulators.gpu-Tuple{Any}" href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gpu(x)</code></pre><p>Move <code>x</code> to CUDA device. It uses <code>Functors.fmap</code> to recursively traverse the fields of the struct <code>x</code>, converting <code>&lt;:AbstractArrays</code> to <code>CuArrays</code>, and ignoring isbitsarrays. For custom structs (e.g. <code>&lt;:BlochSimulator</code> or <code>&lt;:AbstractTrajectory</code>), it is required that <code>typeof(x)</code> be made a <code>Functors.@functor</code> (e.g. <code>@functor FISP</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscarvanderheide/BlochSimulators.jl/blob/42b96bee2594432e9b78430c1ab040796dfc0fda/src/utils/gpu.jl#L6-L13">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#BlochSimulators.AbstractTissueProperties"><code>BlochSimulators.AbstractTissueProperties</code></a></li><li><a href="#BlochSimulators.AbstractTrajectory"><code>BlochSimulators.AbstractTrajectory</code></a></li><li><a href="#BlochSimulators.BlochSimulator"><code>BlochSimulators.BlochSimulator</code></a></li><li><a href="#BlochSimulators.CartesianTrajectory2D"><code>BlochSimulators.CartesianTrajectory2D</code></a></li><li><a href="#BlochSimulators.EPGSimulator"><code>BlochSimulators.EPGSimulator</code></a></li><li><a href="#BlochSimulators.Generic2D"><code>BlochSimulators.Generic2D</code></a></li><li><a href="#BlochSimulators.Generic3D"><code>BlochSimulators.Generic3D</code></a></li><li><a href="#BlochSimulators.Isochromat"><code>BlochSimulators.Isochromat</code></a></li><li><a href="#BlochSimulators.IsochromatSimulator"><code>BlochSimulators.IsochromatSimulator</code></a></li><li><a href="#BlochSimulators.RadialTrajectory2D"><code>BlochSimulators.RadialTrajectory2D</code></a></li><li><a href="#BlochSimulators.SpokesTrajectory"><code>BlochSimulators.SpokesTrajectory</code></a></li><li><a href="#BlochSimulators.F̄₋-Tuple{Any}"><code>BlochSimulators.F̄₋</code></a></li><li><a href="#BlochSimulators.F₊-Tuple{Any}"><code>BlochSimulators.F₊</code></a></li><li><a href="#BlochSimulators.Z-Tuple{Any}"><code>BlochSimulators.Z</code></a></li><li><a href="#BlochSimulators._all_arrays_are_cuarrays-Tuple{Any}"><code>BlochSimulators._all_arrays_are_cuarrays</code></a></li><li><a href="#BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}"><code>BlochSimulators._allocate_array_on_resource</code></a></li><li><a href="#BlochSimulators._allocate_magnetization_array-Tuple{Any, Any, Any}"><code>BlochSimulators._allocate_magnetization_array</code></a></li><li><a href="#BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T&lt;:Complex"><code>BlochSimulators._allocate_signal_array</code></a></li><li><a href="#BlochSimulators._signal_per_coil!-NTuple{7, Any}"><code>BlochSimulators._signal_per_coil!</code></a></li><li><a href="#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory2D, Any}"><code>BlochSimulators.add_gradient_delay!</code></a></li><li><a href="#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T"><code>BlochSimulators.decay</code></a></li><li><a href="#BlochSimulators.decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any}"><code>BlochSimulators.decay!</code></a></li><li><a href="#BlochSimulators.dephasing!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.dephasing!</code></a></li><li><a href="#BlochSimulators.diffuse!-Tuple{Any, Any}"><code>BlochSimulators.diffuse!</code></a></li><li><a href="#BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T&lt;:Real"><code>BlochSimulators.diffusion_decay_matrix</code></a></li><li><a href="#BlochSimulators.diffusion_decay_matrix-Union{Tuple{T}, Tuple{BlochSimulators.ConfigurationStatesSubset, T}} where T&lt;:Real"><code>BlochSimulators.diffusion_decay_matrix</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Real, Unitful.Quantity{&lt;:Real}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T&lt;:Union{Complex, Unitful.Quantity{&lt;:Complex}}"><code>BlochSimulators.excite!</code></a></li><li><a href="#BlochSimulators.f32-Tuple{Any}"><code>BlochSimulators.f32</code></a></li><li><a href="#BlochSimulators.f64-Tuple{Any}"><code>BlochSimulators.f64</code></a></li><li><a href="#BlochSimulators.gpu-Tuple{Any}"><code>BlochSimulators.gpu</code></a></li><li><a href="#BlochSimulators.initial_conditions!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.initial_conditions!</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}"><code>BlochSimulators.initialize_states</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueProperties}} where T"><code>BlochSimulators.invert</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates, AbstractTissueProperties}"><code>BlochSimulators.invert!</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory2D}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory2D}"><code>BlochSimulators.kspace_coordinates</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, StructArrays.StructArray{&lt;:AbstractTissueProperties}, CartesianTrajectory2D, StructArrays.StructArray{&lt;:Coordinates}, Any}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.magnetization_to_signal-NTuple{6, Any}"><code>BlochSimulators.magnetization_to_signal</code></a></li><li><a href="#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T"><code>BlochSimulators.regrowth</code></a></li><li><a href="#BlochSimulators.regrowth!-Tuple{BlochSimulators.AbstractConfigurationStates, Any}"><code>BlochSimulators.regrowth!</code></a></li><li><a href="#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties, Any}} where T"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueProperties}"><code>BlochSimulators.rotate</code></a></li><li><a href="#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T"><code>BlochSimulators.rotate!</code></a></li><li><a href="#BlochSimulators.rotate_decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any, Any}"><code>BlochSimulators.rotate_decay!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.sample_transverse!</code></a></li><li><a href="#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{&lt;:S}, Union{Integer, CartesianIndex}, Isochromat}} where S"><code>BlochSimulators.sample_xyz!</code></a></li><li><a href="#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.sample_Ω!</code></a></li><li><a href="#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory2D}"><code>BlochSimulators.sampling_mask</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, Any}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, AbstractTissueProperties}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{BlochSimulator, StructArrays.StructArray}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, CUDA.CuArray}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:AbstractTissueProperties}}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization-Tuple{Any, DistributedArrays.DArray}"><code>BlochSimulators.simulate_magnetization</code></a></li><li><a href="#BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}"><code>BlochSimulators.simulate_magnetization!</code></a></li><li><a href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{Any, BlochSimulator, AbstractArray{&lt;:AbstractTissueProperties{N, T}}, Any, Any}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a></li><li><a href="#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, StructArrays.StructArray{&lt;:AbstractTissueProperties{N, T}}, AbstractTrajectory{T}, StructArrays.StructArray{&lt;:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}"><code>BlochSimulators.simulate_signal</code></a></li><li><a href="#BlochSimulators.simulate_signal-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{&lt;:StructArrays.StructArray{&lt;:AbstractTissueProperties}}, AbstractTrajectory, AbstractVector{&lt;:StructArrays.StructArray{&lt;:Coordinates}}, AbstractVector{&lt;:AbstractMatrix{&lt;:Complex}}}"><code>BlochSimulators.simulate_signal</code></a></li><li><a href="#BlochSimulators.spoil!-Tuple{BlochSimulators.AbstractConfigurationStates}"><code>BlochSimulators.spoil!</code></a></li><li><a href="#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}"><code>BlochSimulators.Ω_eltype</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../adiabatic/">« Adiabatic inversion</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 22 January 2026 08:49">Thursday 22 January 2026</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
