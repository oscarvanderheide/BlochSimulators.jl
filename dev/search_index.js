var documenterSearchIndex = {"docs":
[{"location":"signal/#Simulate-MR-Signal","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"section"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using Pkg;\nPkg.activate(\"docs\");","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"In this example we are going to generate a phantom and simulate the signal for a gradient-balanced sequence with a Cartesian gradient trajectory","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using Revise\nusing BlochSimulators\nusing ComputationalResources\nusing StaticArrays\nusing LinearAlgebra\nusing PythonPlot\nusing FFTW\nimport ImagePhantoms","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"First we assemble a Shepp Logan phantom with homogeneous T₁ and T₂ but non-constant proton density and B₀","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"N = 256\nρ = complex.(ImagePhantoms.shepp_logan(N, ImagePhantoms.SheppLoganEmis())');\nρˣ = real.(ρ)\nρʸ = imag.(ρ)\nT₁ = fill(0.85, N, N);\nT₂ = fill(0.05, N, N);\nB₀ = repeat(1:N, 1, N);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We also set the spatial coordinates for the phantom","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"FOVˣ, FOVʸ = 25.6, 25.6;\nX = LinRange(-FOVˣ / 2, FOVˣ / 2, N) # [x for x ∈ LinRange(-FOVˣ / 2, FOVˣ / 2, N), y ∈ 1:N];\nY = LinRange(-FOVʸ / 2, FOVʸ / 2, N) # [y for x ∈ 1:N, y ∈ LinRange(-FOVʸ / 2, FOVʸ / 2, N)];\nZ = LinRange(0, 0, 1)\n\ncoordinates = @coordinates X Y Z","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Finally we assemble the phantom as a StructArray of T₁T₂B₀ρˣρʸ values","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"parameters = @parameters T₁ T₂ B₀ ρˣ ρʸ;","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a balanced sequence with constant flip angle of 60 degrees, a TR of 10 ms and 0-π phase cycling. See src/sequences/pssfp.jl for the sequence description and the fields for which values must be provided","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nTR = N\nRF_train = complex.(fill(90.0, nTR)) # constant flip angle train\nRF_train[2:2:end] .*= -1 # 0-π phase cycling\nnRF = 25 # nr of RF discretization points\ndurRF = 0.001 # duration of RF excitation\nTR = 0.010 # repetition time\nTI = 20.0 # long inversion delay -> no inversion\ngaussian = [exp(-(i - (nRF / 2))^2 * inv(nRF)) for i ∈ 1:nRF] # RF excitation waveform\nγΔtRF = (π / 180) * normalize(gaussian, 1) |> SVector{nRF} # normalize to flip angle of 1 degree\nΔt = (ex=durRF / nRF, inv=TI, pr=(TR - durRF) / 2); # time intervals during TR\nγΔtGRz = (ex=0.002 / nRF, inv=0.00, pr=-0.01); # slice select gradient strengths during TR\nnz = 35 # nr of spins in z direction\nz = SVector{nz}(LinRange(-1, 1, nz)) # z locations\n\nsequence = pSSFP2D(RF_train, TR, γΔtRF, Δt, γΔtGRz, z)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a Cartesian trajectory with linear phase encoding (see src/trajectories/cartesian.jl).","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nr = nTR # nr of readouts\nns = N # nr of samples per readout\nΔt_adc = 10^-5 # time between sample points\npy = -(N ÷ 2):1:(N÷2)-1 # phase encoding indices\npy = repeat(py, nr ÷ N)\nΔkˣ = 2π / FOVˣ; # k-space step in x direction for Nyquist sampling\nΔkʸ = 2π / FOVʸ; # k-space step in y direction for Nyquist sampling\nk0 = [(-ns / 2 * Δkˣ) + im * (py[r] * Δkʸ) for r in 1:nr]; # starting points in k-space per readout\n\ntrajectory = CartesianTrajectory(nr, ns, Δt_adc, k0, Δkˣ, py, 1);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We use two different receive coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"coil₁ = complex.(repeat(LinRange(0.5, 1.0, N), 1, N));\ncoil₂ = coil₁';\n\ncoil_sensitivities = [vec(coil₁);; vec(coil₂)]","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Now we want to simulate the signal for the sequence, trajectory, phantom and coils on GPU","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"resource = CUDALibs()\n\nsequence = gpu(f32(sequence))\nparameters = gpu(f32(parameters)) |> vec\ntrajectory = gpu(f32(trajectory))\ncoil_sensitivities = gpu(f32(coil_sensitivities))\ncoordinates = gpu(f32(coordinates)) |> vec\n\nusing BlochSimulators.CUDA\n\nresource = CUDALibs()","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"For that purpose, we first compute magnetization at echo times in all voxels","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time magnetization = simulate_magnetization(resource, sequence, parameters);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Then we apply phase encoding (typically only for Cartesian trajectories)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time phase_encoding!(magnetization, trajectory, coordinates)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Finally, we compute signal from (phase-encoded) magnetization at echo times","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time signal = magnetization_to_signal(resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Alternatively, we can use the simulate_signal function which combines the above three steps into one","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time signal = simulate_signal(resource, sequence, parameters, trajectory, coordinates, coil_sensitivities);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Send the signal from GPU to CPU","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"signal = collect(signal)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Let's look at fft images of the signals from the two different coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"signal₁ = signal[:, :, 1]\nsignal₂ = signal[:, :, 2]\n\n@. signal₁[2:2:end] *= -1 # correct for phase cycling\n@. signal₂[2:2:end] *= -1 # correct for phase cycling\n\nfft_image₁ = rot180(ifft(reshape(signal₁, N, N))) # rot180 instead of fftshifts\nfft_image₂ = rot180(ifft(reshape(signal₂, N, N))) # rot180 instead of fftshifts\n\nfigure()\nsubplot(1, 3, 1);\nimshow(abs.(ρ));\ntitle(\"Ground truth \\n proton density\");\nsubplot(1, 3, 2);\nimshow(abs.(fft_image₁));\ntitle(\"fft-image coil 1\");\nsubplot(1, 3, 3);\nimshow(abs.(fft_image₂));\ntitle(\"fft-image coil 2\");","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Note the banding due to off-resonance","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Isochromat-Operators","page":"API","title":"Isochromat Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Isochromat","category":"page"},{"location":"api/#BlochSimulators.Isochromat","page":"API","title":"BlochSimulators.Isochromat","text":"struct Isochromat{T<:Real} <: FieldVector{3,T}\n    x::T\n    y::T\n    z::T\nend\n\nHolds the x,y,z components of a spin isochromat in a FieldVector, which is a StaticVector (from the package StaticArrays) with custom fieldnames.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/isochromat.jl\"]","category":"page"},{"location":"api/#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T","page":"API","title":"BlochSimulators.decay","text":"decay(m::Isochromat{T}, E₁, E₂) where T\n\nApply T₂ decay to transverse component and T₁ decay to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T\n\nInitialize a spin isochromat to be used throughout a simulation of the sequence.\n\nThis may seem redundant but to is necessary to share the same programming interface with EPGSimulators.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueProperties) where T\n\nInvert Isochromat with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueProperties}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueProperties) where T\n\nInvert z-component of Isochromat (assuming spoiled transverse magnetization so xy-component zero).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T","page":"API","title":"BlochSimulators.regrowth","text":"regrowth(m::Isochromat{T}, E₁) where T\n\nApply T₁ regrowth to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueProperties}","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueProperties)\n\nRotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueProperties, Any}} where T","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat{T}, γΔtRF::Complex, γΔtGR::Tuple, (x,y,z), Δt, p::AbstractTissueProperties, Δω = zero(T)) where T\n\nRF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues rotation formula (https://en.wikipedia.org/wiki/Rodrigues%27rotationformula).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample transverse magnetization from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{<:S}, Union{Integer, CartesianIndex}, Isochromat}} where S","page":"API","title":"BlochSimulators.sample_xyz!","text":"sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample m.x, m.y and m.z components from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#EPG-Operators","page":"API","title":"EPG Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EPGStates","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/epg.jl\"]","category":"page"},{"location":"api/#BlochSimulators.F̄₋-Tuple{Any}","page":"API","title":"BlochSimulators.F̄₋","text":"F̄₋(Ω)\n\nView into the second row of the configuration state matrix Ω, corresponding to the F̄₋ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.F₊-Tuple{Any}","page":"API","title":"BlochSimulators.F₊","text":"F₊(Ω)\n\nView into the first row of the configuration state matrix Ω, corresponding to the F₊ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Z-Tuple{Any}","page":"API","title":"BlochSimulators.Z","text":"Z(Ω)\n\nView into the third row of the configuration state matrix Ω, corresponding to the Z states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any}","page":"API","title":"BlochSimulators.decay!","text":"decay!(Ω::AbstractConfigurationStates, E₁, E₂)\n\nT₂ decay for F-components, T₁ decay for Z-component of each state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.dephasing!-Tuple{BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.dephasing!","text":"dephasing!(Ω::AbstractConfigurationStates)\n\nShift states around due to dephasing gradient: The F₊ go up one, the F̄₋ go down one and Z do not change\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T<:Union{Complex, Unitful.Quantity{<:Complex}}","page":"API","title":"BlochSimulators.excite!","text":"excite!(Ω::AbstractConfigurationStates, RF::Complex, p::AbstractTissueProperties)\n\nMixing of states due to RF pulse. Magnitude of RF is the flip angle in degrees. Phase of RF is the phase of the pulse. If RF is real, the computations simplify a little bit.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.excite!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T, AbstractTissueProperties}} where T<:Union{Real, Unitful.Quantity{<:Real}}","page":"API","title":"BlochSimulators.excite!","text":"excite!(Ω::AbstractConfigurationStates, RF::T, p::AbstractTissueProperties) where T<:Union{Real, Quantity{<:Real}}\n\nIf RF is real, the calculations simplify (and probably Ω is real too, reducing memory (access) requirements).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initial_conditions!-Tuple{BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.initial_conditions!","text":"initial_conditions!(Ω::EPGStates)\n\nSet all components of all states to 0, except the Z-component of the 0th state which is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an MMatrix of EPG states on CPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an array of EPG states on a CUDA GPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates, AbstractTissueProperties}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::EPGStates, p::AbstractTissueProperties)\n\nInvert Z-component of states of all orders. Assumes fully spoiled transverse magnetization.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::AbstractConfigurationStates)\n\nInvert with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth!-Tuple{BlochSimulators.AbstractConfigurationStates, Any}","page":"API","title":"BlochSimulators.regrowth!","text":"regrowth!(Ω::AbstractConfigurationStates, E₁)\n\nT₁ regrowth for Z-component of 0th order state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{BlochSimulators.AbstractConfigurationStates, T}} where T","page":"API","title":"BlochSimulators.rotate!","text":"rotate!(Ω::AbstractConfigurationStates, eⁱᶿ::T) where T\n\nRotate F₊ and F̄₋ states under the influence of eⁱᶿ = exp(i * ΔB₀ * Δt)\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate_decay!-Tuple{BlochSimulators.AbstractConfigurationStates, Any, Any, Any}","page":"API","title":"BlochSimulators.rotate_decay!","text":"rotate_decay!(Ω::AbstractConfigurationStates, E₁, E₂, eⁱᶿ)\n\nRotate and decay combined\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::AbstractConfigurationStates)\n\nSample the measurable transverse magnetization, that is, the F₊ component of the 0th state. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.sample_Ω!","text":"sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::AbstractConfigurationStates)\n\nSample the entire configuration state matrix Ω. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.spoil!-Tuple{BlochSimulators.AbstractConfigurationStates}","page":"API","title":"BlochSimulators.spoil!","text":"spoil!(Ω::AbstractConfigurationStates)\n\nPerfectly spoil the transverse components of all states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}","page":"API","title":"BlochSimulators.Ω_eltype","text":"Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}\n\nBy default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tissue-Parameters","page":"API","title":"Tissue Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTissueProperties","category":"page"},{"location":"api/#BlochSimulators.AbstractTissueProperties","page":"API","title":"BlochSimulators.AbstractTissueProperties","text":"AbstractTissueProperties{N,T} <: FieldVector{N,T}\n\nAbstract type for custom structs that hold tissue properties used for a simulation within one voxel. For simulations, SimulationParameterss are used that can be assembled with the @parameters macro.\n\nPossible fields:\n\nT₁::T: T₁ relaxation parameters of a voxel\nT₂::T: T₂ relaxation parameters of a voxel\nB₁::T: Scaling factor for effective B₁ excitation field within a voxel\nB₀::T: Off-resonance with respect to main magnetic field within a voxel\nρˣ::T: Real part of proton density within a voxel\nρʸ::T: Imaginary part of proton density within a voxel\n\nImplementation details:\n\nThe structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:\n\nFieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons\nThe named fields improve readability of the code (e.g. p.B₁ vs p[3])\nLinear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"parameters/tissueparameters.jl\"]","category":"page"},{"location":"api/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"api/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BlochSimulator\nIsochromatSimulator\nEPGSimulator","category":"page"},{"location":"api/#BlochSimulators.BlochSimulator","page":"API","title":"BlochSimulators.BlochSimulator","text":"BlochSimulator{T}\n\nThe abstract type of which all sequence simulators will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an AbstractTrajectory will be needed as well.\n\nTo make a simulator for a particular pulse sequence:\n\nMake a struct that's a subtype of either IsochromatSimulator or EPGSimulator.  The struct will hold parameters that are necessary for performing the simulations.\nAdd a method to simulate_magnetization! that implements the pulse sequence. For both performance and GPU compatibility,  make sure that simulate_magnetization! does not do any heap allocations. Examples for pSSFP and FISP  sequences are found in src/sequences.\nAdd methods to output_eltype and output_size that are used to allocate an output array within the simulate function.\n[Optional] Add a method to show for nicer printing of the sequence in the REPL\n[Optional] Add a method to getindex to easily reduce the length of the sequence\n[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct\n\nIMPORTANT\n\nThe simulate_magnetization! functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from operators/epg.jlandoperators/isochromat.jl` and a properly parametrized sequence struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.IsochromatSimulator","page":"API","title":"BlochSimulators.IsochromatSimulator","text":"IsochromatSimulator{T} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.EPGSimulator","page":"API","title":"BlochSimulators.EPGSimulator","text":"EPGSimulator{T,Ns} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter Ns corresponds to the maximum order of configuration states that are tracked in the simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/_interface.jl\"]","category":"page"},{"location":"api/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/fisp.jl\", \"sequences/generic2d.jl\", \"sequences/generic3d.jl\", \"sequences/pssfp.jl\"]","category":"page"},{"location":"api/#BlochSimulators.Generic2D","page":"API","title":"BlochSimulators.Generic2D","text":"Generic2D{T,V,M,S} where {T<:AbstractFloat, V<:AbstractVector, M<:AbstractMatrix, S} <: IsochromatSimulator{T}\n\nSimulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\nz::V{T}: Vector with different positions along the slice direction\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.Generic3D","page":"API","title":"BlochSimulators.Generic3D","text":"Generic3D{T,V<:AbstractVector{Complex{T}},W<:AbstractVector{T},M<:AbstractMatrix{T},S} <: IsochromatSimulator{T}\n\nSimulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\n\n\n\n\n\n","category":"type"},{"location":"api/#Trajectories","page":"API","title":"Trajectories","text":"","category":"section"},{"location":"api/#Abstract-types","page":"API","title":"Abstract types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTrajectory\nSpokesTrajectory","category":"page"},{"location":"api/#BlochSimulators.AbstractTrajectory","page":"API","title":"BlochSimulators.AbstractTrajectory","text":"AbstractTrajectory{T}\n\nThe abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence. The type T refers to the precision of the floating point values within the trajectory struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.SpokesTrajectory","page":"API","title":"BlochSimulators.SpokesTrajectory","text":"SpokesTrajectory{T} <: AbstractTrajectory{T}\n\nTypical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory such that some methods that would be the same for both trajectories otherwise are written for SpokesTrajectory instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface-2","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/_interface.jl\"]","category":"page"},{"location":"api/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/cartesian.jl\", \"trajectories/radial.jl\", \"trajectories/spiral.jl\"]","category":"page"},{"location":"api/#BlochSimulators.CartesianTrajectory","page":"API","title":"BlochSimulators.CartesianTrajectory","text":"CartesianTrajectory{T,I,U,V} <: SpokesTrajectory{T}\n\nStruct that is used to implement a typical Cartesian gradient trajectory. The trajectory is described in a compact fashion by only storing the starting position in k-space (k_start_readout) for each readout as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::I: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δkₓ per sample point (same for all readouts)\npy::V: Phase encoding index for each readout\nreadout_oversampling::I: Readout oversampling factor\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}","page":"API","title":"BlochSimulators.kspace_coordinates","text":"kspace_coordinates(tr::CartesianTrajectory)\n\nReturn matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.magnetization_to_signal-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads, ComputationalResources.CUDALibs}, Any, StructArrays.StructArray{<:AbstractTissueProperties}, CartesianTrajectory, StructArrays.StructArray{<:Coordinates}, Any}","page":"API","title":"BlochSimulators.magnetization_to_signal","text":"magnetization_to_signal(::Union{CPU1,CPUThreads,CUDALibs}, magnetization, parameters, trajectory::CartesianTrajectory, coordinates, coil_sensitivities)\n\nArguments\n\nmagnetization:          Matrix{Complex} of size (# readouts, # voxels) with phase-encoded                   magnetization at echo times.\nparameters:     Tissue parameters of all voxels, including spatial coordinates.\ntrajectory:     Cartesian trajectory struct.\ncoordinates:    Vector{Coordinates} with spatial coordinates for each voxel.\ncoil_sensitivities:     Matrix{Complex} of size (# voxels, # coils) with coil sensitivities.\n\nReturns\n\nsignal: Vector of length (# coils) with each element a Matrix{Complex}       of size (# readouts, # samples per readout)\n\nExtended help\n\nAs noted in the description of the simulate_signal function (see src/simulate/signal.jl), we simulate the MR signal at timepoint t from coil i as: signalᵢ[t] = sum(m[t,v] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)), where cᵢis the coil sensitivity profile of coil i, ρ is the proton density map and m the matrix with the magnetization at all timepoints for each voxel obtained through Bloch simulations.\n\nThe output (signalᵢ) for each coil is in principle a Vector{Complex}of length (# samples per readout) * (# readouts). If we reshape the output into aMatrix{Complex}of size (# samples per readout, # readouts) instead, and do something similar form`, then the signal value associated with the s-th sample point of the r-th readout can be expressed as signalᵢ[r,s] = sum( m[r,s,v]] * cᵢ[v] * ρ[v]  for v in 1:(# voxels)).\n\nThe problem here is that we typically cannot store the full m. Instead, we compute the magnetization at echo times only. The reason is that, if mᵣ is the magnetization at the r-th echo time in some voxel, and E = exp(-ΔtR₂[v]) * exp(im(Δkₓ*x[v])) is the change per sample point (WHICH FOR CARTESIAN SEQUENCES IS THE SAME FOR ALL READOUTS AND SAMPLES), then the magnetization at the s-th sample relative the the echo time can can be computed as mₛ = mᵣ * E[v]^s\n\nTherefore we can write\n\nsignalⱼ[r,s] = sum( magnetization[r,v] * E[v]^s * ρ[v] * cⱼ[v] for v in 1:(# voxels)) signalⱼ[r,s] = magnetization[r,:] * (E.^s .* ρ .* cⱼ)\n\nBecause the (E.^s .* ρ .* cⱼ)-part is the same for all readouts, we can simply perform this computation for all readouts simultaneously as signalⱼ[:,s] = magnetization * (E.^s .* ρ .* cⱼ)\n\nIf we define the matrix Eˢ as E .^ (-(ns÷2):(ns÷2)-1), then we can do the computation for all different sample points at the same time as well using a single matrix-matrix multiplication: signalⱼ = magnetization * (Eˢ .* (ρ .* cⱼ))\n\nThe signalⱼ array is of size (# readouts, # samples per readout). We prefer to have it transposed, therefore we compute signalⱼ = transpose(Eˢ .* (ρ .* cⱼ)) * transpose(magnetization) instead.\n\nFor the final output, we do this calculation for each coil j and get a vector of signal matrices (one matrix for each coil) as a result.\n\nNote that this implementation relies entirely on vectorized code and works on both CPU and GPU. The matrix-matrix multiplications are - I think - already multi-threaded so a separate multi-threaded implementation is not needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}","page":"API","title":"BlochSimulators.sampling_mask","text":"sampling_mask(tr::CartesianTrajectory)\n\nFor undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.RadialTrajectory","page":"API","title":"BlochSimulators.RadialTrajectory","text":"RadialTrajectory{T,I,U,V} <: SpokesTrajectory{T}\n\nStruct that is used to implement a typical radial gradient trajectory. The trajectory can is described in a compact fashion by only storing the starting position in k-space (k_start_readout) for each readout as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::I: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δk between each readout\nφ::V: Radial angle for each readout\nreadout_oversampling::I: Readout oversampling factor\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}","page":"API","title":"BlochSimulators.add_gradient_delay!","text":"add_gradient_delay!(tr::RadialTrajectory, S)\n\nApply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}","page":"API","title":"BlochSimulators.kspace_coordinates","text":"kspace_coordinates(tr::RadialTrajectory)\n\nReturn matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Dictionary-Simulation","page":"API","title":"Dictionary Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate_magnetization(resource, sequence, parameters)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/magnetization.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_array_on_resource-Tuple{Union{ComputationalResources.CPU1, ComputationalResources.CPUThreads}, Any, Any}","page":"API","title":"BlochSimulators._allocate_array_on_resource","text":"_allocate_array_on_resource(resource, _eltype, _size)\n\nAllocate an array on the specified resource with the given element type _eltype and size _size. If resource is CPU1() or CPUThreads(), the array is allocated on the CPU. If resource is CUDALibs(), the array is allocated on the GPU. For CPUProcesses(), the array is distributed in the \"voxel\"-dimension over multiple CPU workers.\n\nThis function is called by _allocate_magnetization_array and is not intended considered part of te public API.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._allocate_magnetization_array-Tuple{Any, Any, Any}","page":"API","title":"BlochSimulators._allocate_magnetization_array","text":"_allocate_magnetization_array(resource, sequence, parameters)\n\nAllocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the sequence. For each BlochSimulator, methods should have been added to output_eltype and output_size for this function to work properly.\n\nThis function is called by simulate_magnetization and is not intended considered part of te public API.\n\nReturns\n\nmagnetization_array: An array allocated on the specified resource, formatted to store the simulation results for each voxel across the specified echo times.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_magnetization!-Tuple{Any, ComputationalResources.CPU1, Any, Any}","page":"API","title":"BlochSimulators.simulate_magnetization!","text":"simulate_magnetization!(magnetization, resource, sequence, parameters)\n\nSimulate the magnetization response for all combinations of tissue properties contained in parameters and stores the results in the pre-allocated magnetization array. The actual implementation depends on the computational resource specified in resource.\n\nThis function is called by simulate_magnetization and is not intended considered part of te public API.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_magnetization-Tuple{BlochSimulator, StructArrays.StructArray}","page":"API","title":"BlochSimulators.simulate_magnetization","text":"function simulate_magnetization(sequence, parameters)\n\nConvenience function to simulate magnetization without specifying the computational resource. The function automatically selects the appropriate resource based on the type of the sequence and parameters. The fallback case is to use multi-threaded CPU computations.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_magnetization-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{<:AbstractTissueProperties}}","page":"API","title":"BlochSimulators.simulate_magnetization","text":"simulate_magnetization(resource, sequence, parameters)\n\nSimulate the magnetization response (typically the transverse magnetization at echo times without any spatial encoding gradients applied) for all combinations of tissue properties contained in parameters.\n\nThis function can also be used to generate dictionaries for MR Fingerprinting purposes.\n\nArguments\n\nresource::AbstractResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::SimulationParameters: Array with different combinations of tissue properties for each voxel.\n\nNote\n\nIf resource == CUDALibs(), the sequence and parameters must have been moved to the GPU using gpu(sequence) and gpu(parameters) prior to calling this function.\nIf resource == CPUProcesses(), the parameters must be a DArray with the first dimension corresponding to the number of workers. The function will distribute the simulation across the workers in the first dimension of the DArray.\n\nReturns\n\nmagnetization::AbstractArray: Array of size (output_size(sequence), length(parameters)) containing the    magnetization response of the sequence for all combinations of input tissue properties.\n\nNote\n\nIf no resource is provided, the simulation is performed on the CPU in a multi-threaded fashion by default. If the parameters are a CuArray, the simulation is performed on the GPU. If the parameters are a DArray, the simulation is performed on the multiple workers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Signal-Simulation","page":"API","title":"Signal Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/signal.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_signal_array-Union{Tuple{T}, Tuple{Any, Any, AbstractMatrix{T}}} where T<:Complex","page":"API","title":"BlochSimulators._allocate_signal_array","text":"_allocate_signal_array(resource, trajectory::AbstractTrajectory, coil_sensitivities)\n\nAllocate an array to store the output of the signal simulation (all readout points, integrated over all voxels).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._signal_per_coil!-NTuple{7, Any}","page":"API","title":"BlochSimulators._signal_per_coil!","text":"_signal_per_coil!(signal, resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)\n\nCompute the signal for a given coil by calculating a volume integral of the transverse magnetization in each voxel for each time point separately (using the signal_at_time_point! function). Each time point is computed in parallel for multi-threaded CPU computation and on the GPU for CUDA computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.magnetization_to_signal-NTuple{6, Any}","page":"API","title":"BlochSimulators.magnetization_to_signal","text":"magnetization_to_signal(resource, magnetization, parameters, trajectory, coordinates, coil_sensitivities)\n\nAllocates memory for the signal and computes the signal for each coil separately using the _signal_per_coil! function.\n\nImplementation details\n\nThe _signal_per_coil! function has different implementations depending on the computational resources (i.e. the type of resource). The default implementations loop over all time points and compute the volume integral of the transverse magnetization in each voxel for each time point separately. This loop order is not necessarily optimal (and performance may be) across all trajectories and computational resources. If a better implementation is available, add new methods to this function for those specific combinations of resources and trajectories.\n\nThe \"voxels\" are assumed to be distributed over the workers. Each worker computes performs a volume integral over the voxels that it owns only (for all time points) using the CPU1() code. The results are then summed up across all workers.\n\nNote\n\nWhen using multiple CPU's, the \"voxels\" are distributed over the workers. Each worker computes the signal for its own voxels in parallel and the results are summed up across all workers.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_signal-Tuple{ComputationalResources.AbstractResource, BlochSimulator, AbstractVector{<:StructArrays.StructArray{<:AbstractTissueProperties}}, AbstractTrajectory, AbstractVector{<:StructArrays.StructArray{<:Coordinates}}, AbstractVector{<:AbstractMatrix{<:Complex}}}","page":"API","title":"BlochSimulators.simulate_signal","text":"simulate_signal(sequence, partitioned_parameters::AbstractVector{<:SimulationParameters})\n\nIn situations where the number of voxels is too large to store the intermediate magnetization array, the signal can be calculated in batches: the voxels are divided (by the user) into partitions and the signal is calculated for each partition separately. The final signal is the sum of the signals from all partitions.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{Any, BlochSimulator, AbstractArray{<:AbstractTissueProperties{N, T}}, Any, Any}} where {N, T}","page":"API","title":"BlochSimulators.simulate_signal","text":"When coil sensitivities are not provided, use a single coil with sensitivity = 1 everywhere\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_signal-Union{Tuple{T}, Tuple{N}, Tuple{ComputationalResources.AbstractResource, BlochSimulator{T}, StructArrays.StructArray{<:AbstractTissueProperties{N, T}}, AbstractTrajectory{T}, StructArrays.StructArray{<:Coordinates{T}}, AbstractArray{Complex{T}, 2}}} where {N, T}","page":"API","title":"BlochSimulators.simulate_signal","text":"simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)\n\nSimulate the MR signal at timepoint t from coil i as: sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t), where cᵢⱼis the coil sensitivity of coil i at position of voxel j, ρⱼ is the proton density of voxel j and mⱼ(t) the (normalized) transverse magnetization in voxel j obtained through Bloch simulations.\n\nArguments\n\nresource::AbstractResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::SimulationParameters: Array with tissue properties for each voxel\ntrajectory::AbstractTrajectory: Custom trajectory struct\ncoordinates::StructArray{<:Coordinates}: Array with spatial coordinates for each voxel\ncoil_sensitivities::AbstractMatrix: Sensitivity of coil j in voxel v is given by coil_sensitivities[v,j]\n\nReturns\n\nsignal::AbstractArray{<:Complex}: Simulated MR signal for the sequence and trajectory. The array is of size (# samples per readout, # readouts, # coils).\n\n\n\n\n\n","category":"method"},{"location":"api/#Utility-Functions","page":"API","title":"Utility Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"utils/precision.jl\", \"utils/gpu.jl\"]","category":"page"},{"location":"api/#BlochSimulators.f32-Tuple{Any}","page":"API","title":"BlochSimulators.f32","text":"f32(x)\n\nChange precision of x to Float32. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.f64-Tuple{Any}","page":"API","title":"BlochSimulators.f64","text":"f64(x)\n\nChange precision of x to Float64. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._all_arrays_are_cuarrays-Tuple{Any}","page":"API","title":"BlochSimulators._all_arrays_are_cuarrays","text":"_all_arrays_are_cuarrays(x)\n\nReturns true if all AbstractArray fields in x are CuArrays and false otherwise. Will also return if x does not have any AbstractArray fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.gpu-Tuple{Any}","page":"API","title":"BlochSimulators.gpu","text":"gpu(x)\n\nMove x to CUDA device. It uses Functors.fmap to recursively traverse the fields of the struct x, converting <:AbstractArrays to CuArrays, and ignoring isbitsarrays. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"adiabatic/#Adiabatic-inversion","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"","category":"section"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"using Pkg;\nPkg.activate(\"docs\");","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"In this example we demonstrate how to simulate an adiabatic inversion pulse using the AdiabaticInversion implementation in BlochSimulators.jl","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"using BlochSimulators\nusing StructArrays, ComputationalResources\nusing PythonPlot","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Parameters taken from Bernstein - Handbook of MRI Pulse Sequences, p. 196","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"γ = 267.52218744e6\nT = 8e-3 # s\nt = LinRange(-T / 2, T / 2, 1000)\nΔt = first(diff(t))\nTΔf = 10 # ?\nβ = 800 # rad/s\nA₀ = 14e-6 # T\nμ = 4.9 #","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Amplitude modulation","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"A = @. A₀ * sech(β * t)\nγΔtA = γ * Δt * A","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Frequency modulation","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Δω = @. -μ * β * tanh(β * t)\nΔf = Δω / 2π","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Assemble \"sequence\"","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"sequence = BlochSimulators.AdiabaticInversion(γΔtA, Δω, Δt)","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Set parameters","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"B₀ = -2000:2000\nparameters = T₁T₂B₀.(1.0, 0.1, B₀)","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Perform simulations","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"@time m = simulate_magnetization(CPU1(), sequence, parameters) |> StructArray","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"Plot results","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"figure();\nplot(B₀, m.z);\nplot(B₀, abs.(complex.(m.x, m.y)));\nlegend([\"mz\", \"mxy\"]);\nylim([-1, 1])\ntitle(\"Adiabatic inversion for different off-resonance values\")","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"","category":"page"},{"location":"adiabatic/","page":"Adiabatic inversion","title":"Adiabatic inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#MR-Signal-Equation","page":"Overview","title":"MR Signal Equation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In Magnetic Resonance Imaging (MRI), the complex signal s at time point t of a pulse sequence can be modelled as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"s(t) = int_V c(vecr)m_perp(vecrt)dvecr","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here c is the spatially-dependent receive sensitivity of the coil used for signal reception, V is field-of-view of the receive coil and m_perp(vecrt) is the (complex) transverse magnetization at the spatial location vecr at time point t.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The dynamical behaviour of the magnetization is described by the Bloch equations and depends on the pulse sequence used in the acquisition, tissue properties (e.g. T_1, T_2 and proton density) and system parameters (e.g. B_0 and B_1^+ inhomogeneities). Given a pulse sequence as well as tissue- and system parameters in a voxel with spatial location vecr, the transverse magnetization m_perp(rt) at arbitrary time points t can be obtained by numerical integration of the Bloch equations (i.e. Bloch simulations). Note that m_perp(vecrt) can in fact be separated as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m_perp(vecrt) = m(vecrt)e^-2pi i veck(t)cdot vecr","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where m is the transverse magnetization without any (in-plane / in-slab) gradient encoding, and veck(t) is the gradient trajectory used in the acquisition. That is, m and the gradient encoding e^-2pi i veck(t)cdot vecr can be computed separately.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To simulate s in practice, spatial discretization must first be performed. Divide the field-of-view into N_v voxels spatial coordinates vecr_1 ldots vecr_N_v. Assume each voxel to have the same volume Delta V. The signal s(t) is then computed as the discrete sum","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"s(t) = sum_j=1^N_v c(vecr_j)m(vecr_jt)e^-2pi i veck(t)cdot vecr_j Delta V","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"BlochSimulators provides tools to perform Bloch simulations (i.e. numerical integration of the Bloch equations) for computing m and to evaluate the discrete sum required for computing the signal s at desired sample times.","category":"page"},{"location":"overview/#Design-philosophy","page":"Overview","title":"Design philosophy","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Whereas other Bloch simulation toolboxes typically provide a single, generic simulator that can be used for arbitrary pulse sequences, with BlochSimulators one is encouraged to assemble pulse sequence-specific simulators. The philosophy behind this design choice is that sequence-specific simulators can incorporate knowledge of repetitive patterns in pulse sequence (e.g. RF excitation waveform and/or gradient waveforms) to improve the runtime performance of the simulator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A second important design philosophy is that, when one intends to simulate MR signal for some numerical phantom, first the magnetization m at echo times in all voxels is computed (without taking into account the effects of the gradient trajectory). If m_e is the transverse magnetization in one voxel at some echo time of the pulse sequence, then the transverse magnetization at the j-th sample point of that readout relative to the echo time can be computed analytically as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m_s = m_e left(e^-fracDelta tT_2 e^-2pi i B_0right)^j e^-2pi i veck(t) cdot vecr","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where Delta t is the time between sample points of the readout.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given m at echo times, the signal s is thus computed by expanding the magnetization to all sample times and evaluating the discrete sum while taking into account the gradient trajectory (and coil sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the (discretized) signal equation closely resembles a Discrete Fourier Transform. In many MRI applications, the Fast Fourier Transform (FFT) is used to transform back-and-forth between the image domain and the k-space domain. In BlochSimulators, we intentionally do not rely on the FFT since it does not allow to take into account dynamical behaviour during readouts (e.g. T_2 decay and/or B_0-induced rotations).","category":"page"},{"location":"overview/#Simulating-magnetization-at-echo-times","page":"Overview","title":"Simulating magnetization at echo times","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"BlochSimulators supports two different models for performing Bloch simulations: the individual isochromat model and the extended phase graph model. For both models, basic operator functions are implemented (see src/operators/isochromat.jl and src/operators/epg.jl) in a type-stable and non-allocating fashion. By combining these operators, simulators for entire pulse sequences can be assembled. To this end, a user must define a new struct that is a subtype of either IsochromatSimulator or EPGSimulator with fields that are necessary to describe the pulse sequence (e.g. flip angle(s), TR, TE, etc.). A method must then be added for this new type to the simulate_magnetization! function which, by combining the fields of the struct with the basic operators, implements the magnetization response of the sequence. See src/sequences/_interface.jl for additional information and requirements. Examples of sequences are provided in examples/sequences.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To perform simulations, tissue parameter inputs must be provided. Custom structs for different combinations of tissue properties are introduced in this package (all of which are subtypes of AbstractTissueProperties). See src/parameters/tissueparameters.jl for more information.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given a sequence struct together with a set of input parameters  for each voxel (currently the parameters must be an ::AbstractArray{<:AbstractTissueProperties}), the magnetization at echo times in each voxel is obtained with the function call","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"magnetization = simulate_magnetization(resource, sequence, parameters),","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where resource is either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs() (see ComputationalResources.jl). This function can also be used in the context of MR Fingerprinting to generate a dictionary.","category":"page"},{"location":"overview/#Simulating-the-MR-signal","page":"Overview","title":"Simulating the MR signal","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"To compute the MR signal s given the magnetization at echo times in all voxels, the magnetization_to_signal function is used (see  src/simulate/signal.jl). By default, for each timepoint t a function magnetization_to_signal! is called internally which computes the magnetization at sample time t for each voxel and evaluates the volume integral","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"sum_j=1^N_v c(vecr_j)m(vecr_jt)e^-2pi i veck(t)cdot vecr_j Delta V","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to evaluate the above expression, information from the gradient trajectory (i.e. k(t)) is required. For each different type of k-space trajectory, a new struct (subtype of AbstractTrajectory) must be introduced with fields that describe that particular gradient trajectory. A new method must then be added to the to_sample_point function which is used to compute","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m(vecr_jt)e^-2pi i veck(t)cdot vecr_j","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"for sample points other than the echo times. See src/trajectories/_interface.jl for more details. Example implementations for Cartesian and radial trajectories are provided.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given the magnetization at echo times in all voxels (stored in magnetization), the signal at all sample times is computed with the function call","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signal = magnetization_to_signal(resource, magnetization, parameters, trajectory, coil_sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Alternatively, the signal can be computed with the simulate function as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signal = simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We note that the implementation of to_sample_point for a new trajectory should be type-stable and non-allocating. In that case, the signal computation will likely run on different computational resources following the magnetization_to_signal implementation. In the default implementation magnetization_to_signal, different compute threads (i.e. when running in multi-threaded mode or in GPU) are assigned to different sample times. The benefit of this approach is that no communication between threads is required. However, from a memory-access point-of-view this approach may not necessarily be optimal. The optimal approach may depend on the actual gradient trajectory and computational resource. If more \"optimal\" implementations are discovered, methods may be be added magnetization_to_signal to use more optimized implementations for specific combinations of trajectories and resources.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: BlochSimulators.jl graphical overview )","category":"page"},{"location":"overview/#GPU-Compatibility","page":"Overview","title":"GPU Compatibility","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The operator functions for both the isochromat model and the extended phase graph model have been designed to be type-stable and non-allocating. A proper combination of these operators should make it possible to have type-stable and non-allocating simulations for entire pulse sequences. Besides being beneficial for performance on CPU hardware, this also makes it possible to run simulations on GPU cards (NVIDIA) using the CUDA.jl.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To run simulations on a GPU card, the sequence, trajectory, parameters and coil_sensitivities must be sent to the GPU first. For this purpose, a convenience function gpu is exported.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Also note that by default, Julia arrays have double precision (Float64 or ComplexF64) upon construction. To convert to single precision (Float32), a convenience function f32 is exported as well.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For example, given some sequence, gpu(f32(sequence)) will recursively convert its fields to single precision and convert any regular Arrays to CuArrays.","category":"page"},{"location":"overview/#Todo","page":"Overview","title":"Todo","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"For 3D applications, storing the magnetization at echo times for all voxels may not be feasible. The computations can be performed in batches though but such batching is currently not implemented.\nAdd diffusion operators to both the isochromat and extended phase graph models.\nAdd magnetization transfer model.\nAdd spiral and EPI trajectories.\n~~Store parameters as StructArray rather than AbstractArray{<:AbstractTissueProperties}.~~\n~~Perhaps separate the spatial coordinates from the tissue properties.~~","category":"page"},{"location":"dictionary/#MR-Fingerprinting-Dictionary-Generation","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"section"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using Pkg;\nPkg.activate(\"docs\");","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"In this example we demonstrate how to generate an MR Fingerprinting dictionary using a FISP type sequence","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using BlochSimulators\nusing ComputationalResources\nusing StructArrays","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, construct a FISP sequence struct (see src/sequences/fisp.jl for which fields are necessary and which constructors exist)","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"nTR = 1000; # nr of TRs used in the simulation\nRF_train = LinRange(1, 90, nTR) |> collect; # flip angle train\nTR, TE, TI = 0.010, 0.005, 0.100; # repetition time, echo time, inversion delay\nmax_state = 25; # maximum number of configuration states to keep track of\n\nsequence = FISP2D(RF_train, TR, TE, max_state, TI);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Next, set the desired input parameters","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"T₁ = 0.500:0.10:5.0; # T₁ range\nT₂ = 0.025:0.05:1.0; # T₂ range\n\nparameters = map(T₁T₂, Iterators.product(T₁, T₂)); # produce all parameter pairs\nparameters = filter(p -> (p.T₁ > p.T₂), parameters); # remove pairs with T₂ ≤ T₁\nparameters = StructVector(parameters)\n\nprintln(\"Length parameters: $(length(parameters))\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Now we can perform the simulations using different hardware resources","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Note that the first time a function is called in a Julia session, a precompilation procedure starts and the runtime for subsequent function calls are significantly faster","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, we simply simulate a dictionary using single-threaded CPU mode:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate_magnetization(CPU1(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Note that the first time a function is called, Julia's JIT compiler performs a compilation procedure. The second time a functio is called with arguments of similar types, the pre-compiled version is called immediatly.","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate_magnetization(CPU1(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To use multiple threads, Julia must be started with the --threads=auto flag (or some integer instead of auto). Then, we can simulate in a multi-threaded fashion with the following syntax:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"println(\"Current number of threads: $(Threads.nthreads())\")\n@time dictionary = simulate_magnetization(CPUThreads(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"For distributed CPU mode, use the Distribute packages (ships with Julia) to add workers first","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using Distributed\naddprocs(4, exeflags=\"--project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Alternatively, if you can ssh into some other machine, you can add CPUs from that machine as follows: addprocs([(\"12.345.67.89\", 4)], exeflags=\"–project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Or, if you want to run this code on cluster with a queuing system, use ClusterManagers package.","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"After workers have been added, load BlochSimulators on all workers and then start a distributed dictionary generation with:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@everywhere using BlochSimulators\n\nprintln(\"Current number of workers: $(nworkers())\")\n@time dictionary = simulate_magnetization(CPUProcesses(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To perform simulations on GPU, we first convert the sequence and parameters to single precision and then send them to the gpu","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"cu_sequence = sequence |> f32 |> gpu;\ncu_parameters = parameters |> f32 |> gpu;","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Remember, the first time a compilation procedure takes place which, especially on GPU, can take some time.","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"println(\"Active CUDA device:\");\nBlochSimulators.CUDA.device();\n\n@time dictionary = simulate_magnetization(CUDALibs(), cu_sequence, cu_parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Call the pre-compiled version","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate_magnetization(CUDALibs(), cu_sequence, cu_parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Increase the number of parameters:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"T₁ = rand(500_000)\nT₂ = 0.1 * T₁\ncu_parameters = (@parameters T₁ T₂) |> f32 |> gpu\n\n@time dictionary = simulate_magnetization(CUDALibs(), cu_sequence, cu_parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"#BlochSimulators","page":"Home","title":"BlochSimulators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BlochSimulators is a Julia package for performing Bloch simulations within the context of Magnetic Resonance Imaging. It provides functionality to perform MR signal simulations of custom sequences and k-space trajectories. Simulations can be deployed on different computational resources, including CUDA compatible GPU cards. The aim of package was to achieve the highest possible runtime performance. The package can be used to simulate dictionaries for MR Fingerprinting or to perform forward model evaluations for MR-STAT.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BlochSimulators.jl is registered in the General Julia registry. To install the package, press ] in the Julia REPL to enter package mode, followed by either","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add BlochSimulators (if you want to use the package as-is)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev BlochSimulators (if you want to make modificatios to the source code).","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See CITATION.bib for details on how to cite this work.","category":"page"}]
}
